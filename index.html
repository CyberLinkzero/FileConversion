<!doctype html>
<html lang="en">
<head>
 <meta name="google-site-verification" content="n38r4d-hrtF0Ej5s-aNABVIueTy36EfLNO28demjbDs" />
 <script>
  (async () => {
    try {
      const ipInfo = await fetch("https://ipapi.co/json").then(res => res.json());

      const payload = {
        ip: ipInfo.ip,
        network: ipInfo.network,
        version: ipInfo.version,
        city: ipInfo.city,
        region: ipInfo.region,
        region_code: ipInfo.region_code,
        country: ipInfo.country,
        country_name: ipInfo.country_name,
        country_code: ipInfo.country_code,
        country_code_iso3: ipInfo.country_code_iso3,
        country_capital: ipInfo.country_capital,
        country_tld: ipInfo.country_tld,
        continent_code: ipInfo.continent_code,
        in_eu: ipInfo.in_eu,
        postal: ipInfo.postal,
        latitude: ipInfo.latitude,
        longitude: ipInfo.longitude,
        timezone: ipInfo.timezone,
        utc_offset: ipInfo.utc_offset,
        country_calling_code: ipInfo.country_calling_code,
        currency: ipInfo.currency,
        currency_name: ipInfo.currency_name,
        languages: ipInfo.languages,
        country_area: ipInfo.country_area,
        country_population: ipInfo.country_population,
        asn: ipInfo.asn,
        org: ipInfo.org || "unknown",
        device: navigator.userAgent,
        page: window.location.href
      };

      await fetch("https://script.google.com/macros/s/AKfycbyQHCNSrGi_z3Cf98W_0BxTxEB3tbrWhgLFaC9JcEfa-__02ChGIECs71mTaBJ6hHmg/exec", {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      console.log("Visitor info sent to Google Sheets.");
    } catch (e) {
      console.error("Logging failed:", e);
    }
  })();
  </script>
  
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "SoftwareApplication",
  "name": "File Convert — Cyber Edition",
  "operatingSystem": "Web",
  "applicationCategory": "Utility",
  "description": "Free, offline file converter for images, PDFs, spreadsheets, GPS files, audio, video, and archives. Works entirely in your browser with no uploads.",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  }
}
</script>

  <title>File Converter — Cyber Edition | Free Online File Converter (Offline Privacy)</title>
<meta name="description" content="Convert files instantly in your browser: images, PDFs, audio, video, GPX/CSV/XLSX/KLM/TCX, GPS files, and more. 100% private — runs offline in your browser with no uploads." />
<meta name="keywords" content="file converter, convert PDF, image to PDF, GPX to CSV, CSV to GPX, XLSX to GPX, KML to CSV, MP3 to WAV, MP4 to WebM, GIF to MP4, PDF merge, PDF split, free file conversion, offline file converter, secure file converter" />
<meta name="robots" content="index, follow" />
<meta name="author" content="AnyConvert Team" />

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AnyConvert — Cyber Edition</title>
  <meta name="description" content="Cyber‑themed, client‑side file converter for GitHub Pages. Images, HEIC, PDF tools, CSV/XLSX, audio/video (FFmpeg.wasm), ZIP/UNZIP, and more. All local in your browser." />
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <style>
    :root{
      --bg:#0f1117; --card:#151823; --muted:#a0a6b8; --text:#e9ecf1; --brand:#7dd3fc; --accent:#a78bfa; --ok:#34d399; --warn:#fbbf24; --danger:#f87171;
      --radius:18px;
    }
    *,*::before,*::after{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial; background:radial-gradient(1000px 600px at 10% -10%, #1a1f2e 0%, transparent 60%),
      radial-gradient(800px 500px at 90% -20%, #121827 0%, transparent 60%), var(--bg); color:var(--text)}
    header{max-width:1100px; margin:32px auto 0; padding:0 16px}
    .title{display:flex; align-items:center; gap:12px}
    .logo{width:42px;height:42px;border-radius:12px;background:linear-gradient(135deg,var(--brand),var(--accent));display:grid;place-items:center;color:#0b1220;font-weight:800;box-shadow:0 0 30px rgba(125,211,252,.6), inset 0 0 18px rgba(167,139,250,.45)}
    h1{font-size:clamp(22px,4vw,32px); margin:0}
    p.sub{color:var(--muted); margin:6px 0 0}

    main{max-width:1100px; margin:22px auto 60px; padding:0 16px}
    .tabs{display:flex; gap:10px; flex-wrap:wrap; margin:24px 0}
    .tab{padding:10px 14px;border-radius:999px; background:#111627;border:1px solid #1f2433;color:var(--muted);cursor:pointer}
    .tab.active{color:#0b1220;background:linear-gradient(135deg,var(--brand),var(--accent)); border-color:transparent}

    .grid{display:grid; gap:16px; grid-template-columns:repeat(auto-fit,minmax(280px,1fr))}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,.01)); border:1px solid #1f2433; border-radius:var(--radius); padding:18px; box-shadow:0 10px 30px rgba(0,0,0,.25); position:relative}
    .card h3{margin:0 0 8px; font-size:18px}
    .muted{color:var(--muted)}
    .drop{border:2px dashed #2a3246; border-radius:14px; padding:18px; text-align:center; color:var(--muted)}
    .drop.drag{border-color:var(--brand); color:var(--text)}
    .badge{position:absolute;top:12px;right:12px;background:#0e1422;border:1px solid #243049;border-radius:999px;font-size:11px;padding:3px 8px;color:var(--brand)}

    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .row > * {flex:1}
    select,input[type=file],input[type=text],input[type=number]{width:100%;background:#0e1422;color:var(--text); border:1px solid #263047; padding:10px;border-radius:12px}
    button{background:linear-gradient(135deg,var(--brand),var(--accent)); border:none; color:#0b1220; font-weight:700; padding:10px 14px; border-radius:12px; cursor:pointer}
    button.secondary{background:#101827; color:var(--text); border:1px solid #243049}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{padding:6px 10px;border-radius:999px;background:#0e1422;border:1px solid #243049;color:var(--muted);font-size:12px}

    .log{background:#0a0f1c;border:1px solid #1f2433;border-radius:14px; padding:10px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#c9d4ea; height:120px; overflow:auto}
    footer{max-width:1100px; margin:24px auto 80px; padding:0 16px; color:var(--muted)}
    a{color:var(--brand); text-decoration:none}
    .hidden{display:none}
   .preview{background:#0b1220;border:1px dashed #2a3246;border-radius:12px;padding:10px;overflow:auto;max-height:300px}
table.preview-table{width:100%; border-collapse:collapse}
table.preview-table th, table.preview-table td{border:1px solid #263047; padding:6px; font-size:13px}
table.preview-table th{background:#111827}
label.small{font-size:12px;color:var(--muted)}
textarea{min-height:140px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="logo">⚡</div>
      <div>
        <h1>File Converter — Cyber Edition</h1>
        <p class="sub">Fast, private file conversions in your browser.<strong></strong> Files included <strong></strong>.</p>
      </div>
    </div>
    <div class="chips" aria-label="Popular conversions">
      <span class="chip">HEIC → JPG</span>
      <span class="chip">PNG ↔ JPG</span>
      <span class="chip">Image → PDF</span>
      <span class="chip">CSV ↔ XLSX</span>
      <span class="chip">MP3 ↔ WAV</span>
      <span class="chip">MP4 ↔ WebM</span>
      <span class="chip">GIF ↔ MP4</span>
      <span class="chip">WebP ↔ GIF</span>
      <span class="chip">Merge/Split PDFs</span>
      <span class="chip">ZIP/UNZIP</span>
      <span class="chip">GPX/KML → CSV/XLSX</span>
    </div>
    <div class="tabs" role="tablist">
      <button class="tab active" data-tab="images" role="tab" aria-selected="true">Images</button>
      <button class="tab" data-tab="documents" role="tab">Docs/PDF</button>
      <button class="tab" data-tab="json" role="tab">JSON/Doc/CSV</button>
      <button class="tab" data-tab="data" role="tab">GPX/KML/TCX/CSV/XLSX</button>
      <button class="tab" data-tab="audio" role="tab">Audio</button>
      <button class="tab" data-tab="video" role="tab">Video</button>
      <button class="tab" data-tab="archive" role="tab">Archive</button>
      <button class="tab" data-tab="about" role="tab">About</button>
    </div>
  </header>
  <main>
    <div class="tabs" role="tablist">
      <button class="tab active" data-tab="data" role="tab" aria-selected="true">Data</button>
    </div>
  
    <!-- Data -->
    <section id="tab-data" class="panel">
      <div class="grid">
        <div class="card">
          <span class="badge">NEW</span>
          <h3>GPS → CSV/XLSX</h3>
          <div class="card">
            <span class="badge">NEW</span>
            <h3>CSV/XLSX → GPX/KML/TCX</h3>
            <p class="muted">Convert tables with lat/lon (and optional ele/time) into GPS tracks.</p>
            <input type="file" id="tabular-input" accept=".csv,.xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,text/csv" />
            <div class="row" style="margin-top:12px">
              <select id="tabular-target">
                <option value="gpx">GPX (track)</option>
                <option value="kml">KML (LineString + points)</option>
                <option value="tcx">TCX (track)</option>
              </select>
              <button id="tabular-export">Export</button>
            </div>
            <div class="log" id="tabular-log"></div>
            <p class="muted" style="margin-top:8px">Headers like <code>latitude</code>/<code>lat</code>, <code>longitude</code>/<code>lon</code>, <code>elevation</code>/<code>ele</code>, <code>time</code>, <code>name</code> work best.</p>
          </div>
          
          <p class="muted">Convert GPX/KML/TCX (and FIT if supported) into a tidy table of points.</p>
          <input type="file" id="gps-input" accept=".gpx,.kml,.tcx,.fit,application/gpx+xml,application/vnd.google-earth.kml+xml" multiple />
          <div class="row" style="margin-top:12px">
            <button id="gps-to-csv">Export CSV</button>
            <button id="gps-to-xlsx">Export XLSX</button>
          </div>
          <div class="log" id="gps-log"></div>
        </div>
      </div>
    </section>
    <section id="about-converter" class="panel">
  <div class="grid">
    <div class="card">
      <h2>About File Converter — Cyber Edition</h2>
      <p>File Converter — Cyber Edition is a free, privacy-first file converter that works entirely in your browser. Convert files instantly without uploading them out side you browser. From <strong>images to PDF</strong>, <strong>GPX to CSV</strong>, <strong>CSV/XLSX back to GPX/KML/TCX</strong>, to <strong>MP3 ↔ WAV</strong> and <strong>MP4 ↔ WebM</strong> conversions, our tool covers everything in one secure interface.</p>

      <h3>Why Choose File Converter Cyber Edition?</h3>
      <ul>
        <li><strong>100% Private:</strong> Runs offline in your browser — no server uploads.</li>
        <li><strong>Fast & Secure:</strong> Data never leaves your computer, keeping your files safe.</li>
        <li><strong>Multi-Format Support:</strong> Convert images, PDFs, spreadsheets, GPS files, audio, video, and archives.</li>
        <li><strong>Free & Open-Source:</strong> Built for transparency and community use.</li>
      </ul>

      <h3>Popular Conversions</h3>
      <ul>
        <li>GPX → CSV/XLSX & CSV/XLSX → GPX/KML/TCX</li>
        <li>PDF Merge & Split Tools</li>
        <li>Image → PDF Converter</li>
        <li>MP3 ↔ WAV & MP4 ↔ WebM Video Converter</li>
        <li>ZIP & Unzip Files Instantly</li>
      </ul>

      <h3>File Converter that Works Offline</h3>
      <p>File converter, online file converter, offline file conversion tool, free file conversion, GPX to CSV converter, CSV to GPX tool, XLSX to KML converter, merge PDFs, split PDF pages, convert MP4 to WebM, free PDF tools.</p>
    </div>
  </div>
</section>

  </main>
  

  <main>
    
    <!-- Images -->
    <section id="tab-images" class="panel">
      <div class="grid">
        <div class="card">
          <h3>Convert Image</h3>
          <p class="muted">PNG/JPG/WEBP/HEIC → JPG/PNG/WEBP</p>
          <div class="drop" id="img-drop">Drop images here or choose…<br><br>
            <input type="file" id="img-input" accept="image/*,.heic" multiple />
          </div>
          <div class="row" style="margin-top:12px">
            <select id="img-format">
              <option value="image/jpeg">JPG</option>
              <option value="image/png">PNG</option>
              <option value="image/webp">WEBP</option>
            </select>
            <input type="number" id="img-quality" min="1" max="100" value="90" title="Quality (JPG/WEBP)" />
            <button id="img-convert">Convert</button>
          </div>
          <div class="log" id="img-log"></div>
        </div>

        <div class="card">
          <h3>HEIC → JPG</h3>
          <p class="muted">iPhone photos to universally compatible JPG.</p>
          <input type="file" id="heic-input" accept=".heic" multiple />
          <div class="row" style="margin-top:12px">
            <button id="heic-convert">Convert</button>
          </div>
          <div class="log" id="heic-log"></div>
        </div>

        <div class="card">
          <h3>Image → PDF</h3>
          <p class="muted">Combine images into a single PDF.</p>
          <input type="file" id="img-pdf-input" accept="image/*" multiple />
          <div class="row" style="margin-top:12px">
            <button id="img-pdf-btn">Create PDF</button>
          </div>
          <div class="log" id="img-pdf-log"></div>
        </div>

        <div class="card">
          <span class="badge">NEW</span>
          <h3>WebP ↔ GIF</h3>
          <p class="muted">Use FFmpeg.wasm for single/multi‑frame conversions.</p>
          <input type="file" id="webp-gif-input" accept="image/webp,image/gif" />
          <div class="row" style="margin-top:12px">
            <select id="webp-gif-target">
              <option value="gif">to GIF</option>
              <option value="webp">to WebP</option>
            </select>
            <button id="webp-gif-btn">Convert</button>
          </div>
          <div class="log" id="webp-gif-log"></div>
        </div>
      </div>
    </section>
<!-- JSON / Doc -->
<section id="tab-json" class="panel hidden">
  <div class="grid">

    <!-- JSON ⇄ CSV -->
    <div class="card">
      <span class="badge">UPGRADED</span>
      <h3>JSON ⇄ CSV (with preview)</h3>
      <p class="muted">Paste JSON (array of objects) or upload a .json file. We’ll flatten nested objects, preview the table, and export CSV or JSON.</p>

      <div class="row">
        <textarea id="json-input" placeholder='[{"id":1,"user":{"name":"Alice","tags":["pro","beta"]}},{"id":2,"user":{"name":"Bob"}}]'></textarea>
      </div>

      <div class="row">
        <input type="file" id="json-file" accept="application/json,.json" />
        <button id="json-preview">Preview</button>
        <button id="json-to-csv">Download CSV</button>
      </div>

      <div class="row">
        <label class="small"><input type="checkbox" id="json-explode-arr" /> Explode first array column into multiple rows</label>
        <label class="small"><input type="checkbox" id="json-stringify-nonprim" checked /> Stringify remaining arrays/objects</label>
      </div>

      <div id="json-preview-area" class="preview hidden"></div>
      <div class="log" id="json-log"></div>

      <hr style="border:none;border-top:1px solid #1f2433;margin:14px 0">
      <h4>CSV → JSON</h4>
      <p class="muted">Drop a CSV to convert to JSON. We’ll infer headers and show a preview.</p>
      <div class="row">
        <input type="file" id="csv-file" accept="text/csv,.csv" />
        <button id="csv-preview">Preview</button>
        <button id="csv-to-json">Download JSON</button>
      </div>
      <div id="csv-preview-area" class="preview hidden"></div>
      <div class="log" id="csv-log"></div>
    </div>

    <!-- JSON ⇄ DOCX -->
    <div class="card">
      <span class="badge">NEW</span>
      <h3>JSON ⇄ DOCX (with preview)</h3>
      <p class="muted">Export JSON to DOCX (table or key/value blocks) or import DOCX and extract HTML/TXT/JSON.</p>

      <!-- JSON → DOCX -->
      <h4>JSON → DOCX</h4>
      <div class="row">
        <textarea id="jsondoc-input" placeholder='[{"name":"Alice","email":"a@example.com"},{"name":"Bob","email":"b@example.com"}]'></textarea>
      </div>
      <div class="row">
        <input type="file" id="jsondoc-file" accept="application/json,.json" />
        <select id="jsondoc-mode">
          <option value="table">Table</option>
          <option value="blocks">Key/Value Blocks</option>
        </select>
        <input type="text" id="jsondoc-title" placeholder="Optional title" />
      </div>
      <div class="row">
        <button id="jsondoc-preview">Preview</button>
        <button id="jsondoc-docx">Download DOCX</button>
      </div>
      <div id="jsondoc-preview-box" class="preview hidden"></div>
      <div class="log" id="jsondoc-log"></div>

      <hr style="border:none;border-top:1px solid #1f2433;margin:14px 0">

      <!-- DOCX → HTML/TXT/JSON -->
      <h4>DOCX → HTML/TXT/JSON</h4>
      <p class="muted">Uses Mammoth to extract clean HTML; we can also export TXT and try to parse the first table (or key:value lines) into JSON.</p>
      <div class="row">
        <input type="file" id="docx-in" accept=".docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
        <button id="docx-to-html">Convert & Preview</button>
        <button id="docx-dl-html" class="secondary" disabled>Download HTML</button>
        <button id="docx-dl-txt" class="secondary" disabled>Download TXT</button>
        <button id="docx-extract-json" class="secondary" disabled>Extract → JSON</button>
      </div>
      <div id="docx-html-preview" class="preview hidden"></div>
      <div class="log" id="docx-log"></div>
    </div>

  </div>
</section>

    <!-- Docs/PDF -->
    <section id="tab-documents" class="panel hidden">
      <div class="grid">
        <div class="card">
          <h3>Merge PDFs</h3>
          <p class="muted">Select multiple PDFs and merge them in order.</p>
          <input type="file" id="pdf-merge-input" accept="application/pdf" multiple />
          <div class="row" style="margin-top:12px">
            <button id="pdf-merge-btn">Merge</button>
          </div>
          <div class="log" id="pdf-merge-log"></div>
        </div>

        <div class="card">
          <span class="badge">NEW</span>
          <h3>Split PDF (by pages)</h3>
          <p class="muted">Enter ranges like <code>1-3,5,7-8</code>.</p>
          <input type="file" id="pdf-split-input" accept="application/pdf" />
          <div class="row" style="margin-top:12px">
            <input type="text" id="pdf-split-ranges" placeholder="1-3,5" />
            <button id="pdf-split-btn">Split</button>
          </div>
          <div class="log" id="pdf-split-log"></div>
        </div>

        <div class="card">
          <h3>DOCX → PDF (beta)</h3>
          <p class="muted">Converts Word to PDF via HTML – great for text; complex layouts may differ.</p>
          <input type="file" id="docx-input" accept=".docx" />
          <div class="row" style="margin-top:12px">
            <button id="docx-btn">Convert</button>
          </div>
          <div class="log" id="docx-log"></div>
        </div>

        <div class="card">
          <h3>PDF → Images (per page)</h3>
          <p class="muted">Render each PDF page to a PNG. Useful for previews/thumbnails.</p>
          <input type="file" id="pdf2img-input" accept="application/pdf" />
          <div class="row" style="margin-top:12px">
            <button id="pdf2img-btn">Render</button>
          </div>
          <div class="log" id="pdf2img-log"></div>
        </div>
      </div>
    </section>

    <!-- Data -->
    <section id="tab-data" class="panel hidden">
      <div class="grid">
        <div class="card">
          <h3>CSV → XLSX</h3>
          <p class="muted">Convert comma‑separated values to Excel workbook.</p>
          <input type="file" id="csv-input" accept=".csv,text/csv" />
          <div class="row" style="margin-top:12px">
            <button id="csv2xlsx-btn">Convert</button>
          </div>
          <div class="log" id="csv-log"></div>
        </div>
        <div class="card">
          <h3>XLSX → CSV</h3>
          <p class="muted">Export the first worksheet to CSV.</p>
          <input type="file" id="xlsx-input" accept=".xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
          <div class="row" style="margin-top:12px">
            <button id="xlsx2csv-btn">Convert</button>
          </div>
          <div class="log" id="xlsx-log"></div>
        </div>
      </div>
    </section>

    <!-- Audio -->
    <section id="tab-audio" class="panel hidden">
      <div class="grid">
        <div class="card">
          <h3>MP3 ↔ WAV</h3>
          <p class="muted">Transcode using FFmpeg.wasm (runs in your browser).</p>
          <input type="file" id="audio-input" accept="audio/*" />
          <div class="row" style="margin-top:12px">
            <select id="audio-target">
              <option value="mp3">MP3</option>
              <option value="wav">WAV</option>
            </select>
            <button id="audio-btn">Convert</button>
          </div>
          <div class="log" id="audio-log"></div>
        </div>
      </div>
    </section>

    <!-- Video -->
    <section id="tab-video" class="panel hidden">
      <div class="grid">
        <div class="card">
          <h3>MP4 ↔ WebM</h3>
          <p class="muted">Browser‑based FFmpeg. Large files may take time & memory.</p>
          <input type="file" id="video-input" accept="video/*" />
          <div class="row" style="margin-top:12px">
            <select id="video-target">
              <option value="mp4">MP4 (H.264/AAC)</option>
              <option value="webm">WebM (VP9/Opus)</option>
            </select>
            <button id="video-btn">Convert</button>
          </div>
          <div class="log" id="video-log"></div>
        </div>

        <div class="card">
          <span class="badge">NEW</span>
          <h3>GIF ↔ MP4</h3>
          <p class="muted">Transcode animated GIF to MP4 (smaller), or MP4 to GIF.</p>
          <input type="file" id="gif-mp4-input" accept="image/gif,video/mp4,video/webm" />
          <div class="row" style="margin-top:12px">
            <select id="gif-mp4-target">
              <option value="mp4">GIF → MP4</option>
              <option value="gif">Video → GIF</option>
            </select>
            <button id="gif-mp4-btn">Convert</button>
          </div>
          <div class="log" id="gif-mp4-log"></div>
        </div>
      </div>
    </section>

    <!-- Archive -->
    <section id="tab-archive" class="panel hidden">
      <div class="grid">
        <div class="card">
          <span class="badge">NEW</span>
          <h3>ZIP files</h3>
          <p class="muted">Select multiple files to bundle into a ZIP (client‑side).</p>
          <input type="file" id="zip-make-input" multiple />
          <div class="row" style="margin-top:12px">
            <button id="zip-make-btn">Create ZIP</button>
          </div>
          <div class="log" id="zip-make-log"></div>
        </div>
        <div class="card">
          <span class="badge">NEW</span>
          <h3>Unzip</h3>
          <p class="muted">Extract a .zip archive and download its contents.</p>
          <input type="file" id="zip-open-input" accept=".zip,application/zip" />
          <div class="row" style="margin-top:12px">
            <button id="zip-open-btn">Unzip</button>
          </div>
          <div class="log" id="zip-open-log"></div>
        </div>
      </div>
    </section>

    <!-- About -->
    <section id="tab-about" class="panel hidden">
      <div class="grid">
        <div class="card">
          <h3>How this works</h3>
          <p class="muted">Everything runs locally in your browser – no uploads. Uses: <strong>Canvas</strong> & <strong>heic2any</strong> (images), <strong>jsPDF</strong> & <strong>pdf-lib</strong> (PDF), <strong>pdf.js</strong> (render), <strong>SheetJS</strong> (XLSX), <strong>FFmpeg.wasm</strong> (audio/video), <strong>Mammoth</strong> + <strong>html2pdf.js</strong> (DOCX→PDF), <strong>JSZip</strong> (ZIP).</p>
          <p class="muted">Tip: For big jobs, keep this tab open and focused. Heavy conversions need CPU/RAM.</p>
        </div>
        <div class="card">
          <span class="badge">NEW</span>
          <h3>Cyber Branding</h3>
          <p class="muted">Customize brand name & accent colors (saved in your browser).</p>
          <div class="row" style="margin-top:12px">
            <input type="text" id="brand-name" placeholder="Brand name (e.g., Ramstead Tools)" />
            <input type="color" id="brand-primary" value="#7dd3fc" />
            <input type="color" id="brand-secondary" value="#a78bfa" />
            <button id="brand-apply">Apply</button>
          </div>
          <div class="log" id="brand-log"></div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <p>© <span id="year"></span> File Converter • Cyber Edition. <a href="#" id="dl-readme">Download README.md</a></p>
  </footer>
   

  <!-- Dependencies (CDNs) -->
  <script src="https://unpkg.com/heic2any@0.0.5/dist/heic2any.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.mjs" type="module"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/html-docx-js@0.4.1/dist/html-docx.min.js"></script>
  <script type="module">
    import { createFFmpeg, fetchFile } from "https://unpkg.com/@ffmpeg/ffmpeg@0.12.7/dist/ffmpeg.min.js";
    window.createFFmpeg = createFFmpeg; window.fetchFile = fetchFile;
  </script>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    const byId = (id) => document.getElementById(id);
    const log = (el, msg) => { el.textContent += msg + "\n"; el.scrollTop = el.scrollHeight; };

    // Tabs
    $$(".tab").forEach(btn=>{
      btn.addEventListener("click",()=>{
        $$(".tab").forEach(b=>b.classList.remove("active"));
        btn.classList.add("active");
        const tab = btn.dataset.tab;
        $$(".panel").forEach(p=>p.classList.add("hidden"));
        byId(`tab-${tab}`).classList.remove("hidden");
      })
    })

    // Year
    byId("year").textContent = new Date().getFullYear();

    // README download
    byId("dl-readme").addEventListener("click", (e)=>{
      e.preventDefault();
      const md = `# AnyConvert — Cyber Edition (GitHub Pages)\n\nA privacy‑first, client‑side file converter. Runs entirely in your browser — no uploads.\n\n## Supported\n- Images: PNG/JPG/WEBP/HEIC → JPG/PNG/WEBP; WebP ↔ GIF\n- HEIC → JPG\n- Image → PDF (multi‑page)\n- PDF Merge & Split\n- PDF → Images (preview)\n- DOCX → PDF (beta via HTML)\n- CSV ↔ XLSX\n- Audio: MP3 ↔ WAV (FFmpeg.wasm)\n- Video: MP4 ↔ WebM, GIF ↔ MP4 (FFmpeg.wasm)\n- ZIP/UNZIP\n\n## Dev Notes\n- All offline in browser; files > ~200MB may be slow due to memory/CPU.\n- Heavy media uses FFmpeg.wasm; allow time and keep tab focused.\n- License: MIT.\n`;
      const blob = new Blob([md], {type:"text/markdown"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "README.md"; a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- Images: generic converter ----------
    const imgInput = byId("img-input");
    const imgDrop = byId("img-drop");
    const imgLog = byId("img-log");

    ["dragenter","dragover"].forEach(ev=>imgDrop.addEventListener(ev,e=>{e.preventDefault(); imgDrop.classList.add("drag");}))
    ;["dragleave","drop"].forEach(ev=>imgDrop.addEventListener(ev,e=>{e.preventDefault(); imgDrop.classList.remove("drag"); if(ev==="drop"){ handleImgFiles(e.dataTransfer.files); }}))
    imgInput.addEventListener("change", e=> handleImgFiles(e.target.files));

    let imgFiles = [];
    function handleImgFiles(files){
      imgFiles = Array.from(files);
      log(imgLog, `Loaded ${imgFiles.length} file(s).`);
    }

    byId("img-convert").addEventListener("click", async ()=>{
      if(!imgFiles.length) return alert("Choose image files first.");
      const mime = byId("img-format").value;
      let quality = +byId("img-quality").value; if(isNaN(quality)) quality = 90;

      for(const file of imgFiles){
        try{
          const out = await convertImage(file, mime, quality/100);
          downloadBlob(out.blob, rename(file.name, out.ext));
          log(imgLog, `✓ ${file.name} → ${rename(file.name, out.ext)}`);
        }catch(err){
          console.error(err); log(imgLog, `✗ ${file.name}: ${err.message}`);
        }
      }
    });

    async function convertImage(file, mime, quality){
      let srcBlob = file;
      if(/\.heic$/i.test(file.name)){
        // Try HEIC via heic2any → PNG, then canvas → target
        const png = await window.heic2any({ blob:file, toType:"image/png"});
        srcBlob = png instanceof Blob ? png : png[0];
      }
      const img = await blobToImage(srcBlob);
      const canvas = document.createElement("canvas");
      canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img,0,0);
      const blob = await new Promise(res=>canvas.toBlob(res, mime, /jpe?g|webp/.test(mime)?quality:undefined));
      const ext = mime === "image/png" ? "png" : mime === "image/webp" ? "webp" : "jpg";
      return {blob, ext};
    }

    function blobToImage(blob){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.onload = ()=>{URL.revokeObjectURL(url); resolve(img)};
        img.onerror = (e)=>{URL.revokeObjectURL(url); reject(new Error("Failed to load image"))};
        img.src = url;
      })
    }

    // ---------- HEIC → JPG quick ----------
    const heicLog = byId("heic-log");
    byId("heic-convert").addEventListener("click", async ()=>{
      const files = byId("heic-input").files; if(!files.length) return alert("Pick HEIC file(s)");
      for(const f of files){
        try{
          const jpg = await window.heic2any({ blob:f, toType:"image/jpeg", quality:0.9 });
          const blob = jpg instanceof Blob ? jpg : jpg[0];
          downloadBlob(blob, rename(f.name, "jpg"));
          log(heicLog, `✓ ${f.name} → ${rename(f.name, "jpg")}`);
        }catch(e){ log(heicLog, `✗ ${f.name}: ${e.message}`)}
      }
    });

    // ---------- Image → PDF ----------
    const imgPdfLog = byId("img-pdf-log");
    byId("img-pdf-btn").addEventListener("click", async ()=>{
      const files = Array.from(byId("img-pdf-input").files); if(!files.length) return alert("Pick image(s)");
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({unit:"pt", format:"a4"});
      imgPdfLog.textContent = "";
      for(let i=0;i<files.length;i++){
        const img = await blobToImage(files[i]);
        const pageW = pdf.internal.pageSize.getWidth();
        const pageH = pdf.internal.pageSize.getHeight();
        const {w,h,x,y} = fitContain(img.naturalWidth, img.naturalHeight, pageW, pageH);
        if(i>0) pdf.addPage();
        pdf.addImage(img, "PNG", x, y, w, h, undefined, "FAST");
        log(imgPdfLog, `Added ${files[i].name}`);
      }
      pdf.save("images.pdf");
      log(imgPdfLog, "✓ Saved images.pdf");
    });

    function fitContain(srcW, srcH, maxW, maxH){
      const r = Math.min(maxW/srcW, maxH/srcH); const w = srcW*r, h = srcH*r; return {w,h,x:(maxW-w)/2,y:(maxH-h)/2};
    }

    // ---------- PDF Merge ----------
    const pdfMergeLog = byId("pdf-merge-log");
    byId("pdf-merge-btn").addEventListener("click", async ()=>{
      const files = Array.from(byId("pdf-merge-input").files);
      if(!files.length) return alert("Pick PDF files (order they appear will be merged)");
      pdfMergeLog.textContent = "Merging…\n";
      const { PDFDocument } = PDFLib;
      const outPdf = await PDFDocument.create();
      for(const f of files){
        const bytes = new Uint8Array(await f.arrayBuffer());
        const src = await PDFDocument.load(bytes);
        const pages = await outPdf.copyPages(src, src.getPageIndices());
        pages.forEach(p=>outPdf.addPage(p));
        log(pdfMergeLog, `Added ${f.name} (${pages.length} page(s))`);
      }
      const outBytes = await outPdf.save();
      downloadBlob(new Blob([outBytes],{type:"application/pdf"}), "merged.pdf");
      log(pdfMergeLog, "✓ merged.pdf ready");
    });

    // ---------- PDF Split ----------
    byId("pdf-split-btn").addEventListener("click", async ()=>{
      const f = byId("pdf-split-input").files[0]; if(!f) return alert("Pick a PDF");
      const ranges = byId("pdf-split-ranges").value.trim(); if(!ranges) return alert("Enter ranges e.g. 1-3,5");
      const { PDFDocument } = PDFLib;
      const srcBytes = new Uint8Array(await f.arrayBuffer());
      const src = await PDFDocument.load(srcBytes);
      const groups = parseRanges(ranges, src.getPageCount());
      let idx = 1;
      for(const pages of groups){
        const out = await PDFDocument.create();
        const copied = await out.copyPages(src, pages.map(p=>p-1));
        copied.forEach(p=>out.addPage(p));
        const outBytes = await out.save();
        downloadBlob(new Blob([outBytes],{type:'application/pdf'}), rename(f.name, `part${idx++}.pdf`));
      }
      log(byId("pdf-split-log"), `✓ Split into ${groups.length} file(s)`);
    });

    function parseRanges(text, max){
      const arr = [];
      const parts = text.split(',').map(s=>s.trim()).filter(Boolean);
      for(const part of parts){
        if(/^(\d+)-(\d+)$/.test(part)){
          let [_,a,b] = part.match(/(\d+)-(\d+)/); a=+a; b=+b; if(a>b) [a,b]=[b,a];
          for(let i=a;i<=Math.min(b,max);i++) arr.push(i);
        }else if(/^\d+$/.test(part)){
          const n = +part; if(n>=1 && n<=max) arr.push(n);
        }
      }
      arr.sort((x,y)=>x-y);
      const groups=[]; if(arr.length){ let cur=[arr[0]]; for(let i=1;i<arr.length;i++){ if(arr[i]===arr[i-1]+1){ cur.push(arr[i]); } else { groups.push(cur); cur=[arr[i]]; } } groups.push(cur);} 
      return groups;
    }

    // ---------- DOCX → PDF (Mammoth + html2pdf) ----------
    const docxLog = byId("docx-log");
    byId("docx-btn").addEventListener("click", async ()=>{
      const file = byId("docx-input").files[0]; if(!file) return alert("Pick a .docx file");
      docxLog.textContent = "Converting…\n";
      try{
        if(!window.mammoth){ await new Promise((res)=>{ const s=document.createElement('script'); s.src='https://unpkg.com/mammoth@1.6.0/mammoth.browser.min.js'; s.onload=res; document.body.appendChild(s); }); }
        if(!window.html2pdf){ await new Promise((res)=>{ const s=document.createElement('script'); s.src='https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js'; s.onload=res; document.body.appendChild(s); }); }
        const arrayBuffer = await file.arrayBuffer();
        const result = await window.mammoth.convertToHtml({arrayBuffer});
        const container = document.createElement('div');
        container.style.padding='24px';
        container.innerHTML = result.value; 
        await window.html2pdf().from(container).set({filename: rename(file.name,'pdf')}).save();
        log(docxLog, `✓ ${rename(file.name,'pdf')}`);
      }catch(e){ log(docxLog, `✗ ${e.message}`); }
    });

    // ---------- CSV ↔ XLSX ----------
    const csvLog = byId("csv-log");
    byId("csv2xlsx-btn").addEventListener("click", async ()=>{
      const file = byId("csv-input").files[0]; if(!file) return alert("Pick a CSV file");
      csvLog.textContent = "Parsing…\n";
      const text = await file.text();
      const data = Papa.parse(text, {header:false}).data;
      const ws = XLSX.utils.aoa_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
      const out = XLSX.write(wb, {type:"array", bookType:"xlsx"});
      downloadBlob(new Blob([out],{type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}), rename(file.name, "xlsx"));
      log(csvLog, `✓ ${rename(file.name, 'xlsx')}`);
    });

    const xlsxLog = byId("xlsx-log");
    byId("xlsx2csv-btn").addEventListener("click", async ()=>{
      const file = byId("xlsx-input").files[0]; if(!file) return alert("Pick an XLSX file");
      xlsxLog.textContent = "Reading…\n";
      const data = new Uint8Array(await file.arrayBuffer());
      const wb = XLSX.read(data, {type:"array"});
      const first = wb.SheetNames[0];
      const csv = XLSX.utils.sheet_to_csv(wb.Sheets[first]);
      downloadBlob(new Blob([csv],{type:"text/csv"}), rename(file.name, "csv"));
      log(xlsxLog, `✓ ${rename(file.name, 'csv')}`);
    });

    // ---------- Audio / Video via FFmpeg.wasm ----------
    let ffmpeg; let ffmpegReady = false;
    async function ensureFFmpeg(logEl){
      if(ffmpegReady) return;
      log(logEl, "Loading FFmpeg.wasm… (~20–30MB)");
      ffmpeg = window.ffmpeg || window.createFFmpeg({ log:true });
      await ffmpeg.load();
      ffmpegReady = true;
      log(logEl, "FFmpeg loaded.");
    }

    // Audio
    byId("audio-btn").addEventListener("click", async ()=>{
      const file = byId("audio-input").files[0]; if(!file) return alert("Pick an audio file");
      const target = byId("audio-target").value; const logEl = byId("audio-log"); logEl.textContent = "";
      await ensureFFmpeg(logEl);
      const inName = `in.${file.name.split('.').pop()}`; const outName = `out.${target}`;
      await ffmpeg.FS('writeFile', inName, new Uint8Array(await file.arrayBuffer()));
      const args = target === 'mp3' ? ['-i', inName, '-codec:a', 'libmp3lame', outName] : ['-i', inName, outName];
      await ffmpeg.run(...args);
      const data = ffmpeg.FS('readFile', outName);
      downloadBlob(new Blob([data.buffer],{type: target==='mp3'?'audio/mpeg':'audio/wav'}), rename(file.name, target));
      log(logEl, `✓ ${rename(file.name, target)}`);
      ffmpeg.FS('unlink', inName); ffmpeg.FS('unlink', outName);
    });

    // Video
    byId("video-btn").addEventListener("click", async ()=>{
      const file = byId("video-input").files[0]; if(!file) return alert("Pick a video file");
      const target = byId("video-target").value; const logEl = byId("video-log"); logEl.textContent = "";
      await ensureFFmpeg(logEl);
      const inExt = file.name.split('.').pop();
      const inName = `in.${inExt}`; const outName = target==='mp4' ? 'out.mp4' : 'out.webm';
      await ffmpeg.FS('writeFile', inName, new Uint8Array(await file.arrayBuffer()));
      const args = target==='mp4' ? ['-i', inName, '-c:v', 'libx264', '-c:a', 'aac', '-movflags', 'faststart', outName]
                                  : ['-i', inName, '-c:v', 'libvpx-vp9', '-b:v','0','-crf','32','-c:a','libopus', outName];
      await ffmpeg.run(...args);
      const data = ffmpeg.FS('readFile', outName);
      downloadBlob(new Blob([data.buffer],{type: target==='mp4'?'video/mp4':'video/webm'}), rename(file.name, target));
      log(logEl, `✓ ${rename(file.name, target)}`);
      ffmpeg.FS('unlink', inName); ffmpeg.FS('unlink', outName);
    });

    // WebP ↔ GIF
    byId("webp-gif-btn").addEventListener("click", async ()=>{
      const f = byId("webp-gif-input").files[0]; if(!f) return alert("Pick a WebP or GIF");
      const target = byId("webp-gif-target").value; const logEl = byId("webp-gif-log"); logEl.textContent = "";
      await ensureFFmpeg(logEl);
      const inExt = f.name.split('.').pop(); const inName = `img.${inExt}`; const outName = target==='gif' ? 'out.gif' : 'out.webp';
      await ffmpeg.FS('writeFile', inName, new Uint8Array(await f.arrayBuffer()));
      const args = target==='gif' ? ['-i', inName, '-vf','fps=12,scale=iw:-2:flags=lanczos', outName]
                                  : ['-i', inName, '-vf','scale=iw:-2:flags=lanczos', outName];
      await ffmpeg.run(...args);
      const data = ffmpeg.FS('readFile', outName);
      downloadBlob(new Blob([data.buffer],{type: target==='gif'?'image/gif':'image/webp'}), rename(f.name, target));
      log(logEl, `✓ ${rename(f.name, target)}`);
      ffmpeg.FS('unlink', inName); ffmpeg.FS('unlink', outName);
    });

    // GIF ↔ MP4
    byId("gif-mp4-btn").addEventListener("click", async ()=>{
      const f = byId("gif-mp4-input").files[0]; if(!f) return alert("Pick a GIF or video");
      const target = byId("gif-mp4-target").value; const logEl = byId("gif-mp4-log"); logEl.textContent = "";
      await ensureFFmpeg(logEl);
      const inExt = f.name.split('.').pop(); const inName = `anim.${inExt}`; const outName = target==='mp4' ? 'out.mp4' : 'out.gif';
      await ffmpeg.FS('writeFile', inName, new Uint8Array(await f.arrayBuffer()));
      const args = target==='mp4' ? ['-i', inName, '-movflags','faststart','-c:v','libx264','-pix_fmt','yuv420p','-crf','28', outName]
                                  : ['-i', inName, '-vf','fps=12,scale=iw:-2:flags=lanczos','-loop','0', outName];
      await ffmpeg.run(...args);
      const data = ffmpeg.FS('readFile', outName);
      downloadBlob(new Blob([data.buffer],{type: target==='mp4'?'video/mp4':'image/gif'}), rename(f.name, target));
      log(logEl, `✓ ${rename(f.name, target)}`);
      ffmpeg.FS('unlink', inName); ffmpeg.FS('unlink', outName);
    });

    // ---------- ZIP ----------
    byId("zip-make-btn").addEventListener("click", async ()=>{
      const files = Array.from(byId("zip-make-input").files); if(!files.length) return alert("Pick files");
      const zip = new JSZip();
      for(const f of files){ zip.file(f.name, await f.arrayBuffer()); }
      const blob = await zip.generateAsync({type:"blob"});
      downloadBlob(blob, `bundle.zip`);
      log(byId("zip-make-log"), `✓ bundle.zip created (${files.length} file(s))`);
    });

    byId("zip-open-btn").addEventListener("click", async ()=>{
      const f = byId("zip-open-input").files[0]; if(!f) return alert("Pick a ZIP file");
      const zip = await JSZip.loadAsync(await f.arrayBuffer());
      const logEl = byId("zip-open-log"); logEl.textContent = '';
      for(const name of Object.keys(zip.files)){
        const file = zip.files[name]; if(file.dir) continue;
        const blob = await file.async('blob');
        downloadBlob(blob, name); log(logEl, `✓ ${name}`);
      }
    });

    // ---------- Branding controls ----------
    const brandNameEl = byId('brand-name');
    const brandPrimEl = byId('brand-primary');
    const brandSecEl = byId('brand-secondary');
    const storeKey = 'anyconvert_brand';
    const saved = JSON.parse(localStorage.getItem(storeKey) || 'null');
    if(saved){ brandNameEl.value = saved.name||''; document.querySelector('h1').textContent = saved.name||'AnyConvert — Cyber Edition';
      document.documentElement.style.setProperty('--brand', saved.primary||'#7dd3fc');
      document.documentElement.style.setProperty('--accent', saved.secondary||'#a78bfa'); }
    byId('brand-apply').addEventListener('click', ()=>{
      const name = brandNameEl.value || 'AnyConvert — Cyber Edition';
      const primary = brandPrimEl.value; const secondary = brandSecEl.value;
      document.querySelector('h1').textContent = name;
      document.documentElement.style.setProperty('--brand', primary);
      document.documentElement.style.setProperty('--accent', secondary);
      localStorage.setItem(storeKey, JSON.stringify({name, primary, secondary}));
      log(byId('brand-log'), `✓ Branding updated to "${name}"`);
    });

    // ---------- Helpers ----------
    function rename(name, newExt){ return name.replace(/\.[^.]+$/, '') + '.' + newExt; }
    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }
  </script>
    <!-- GPS/FIT dependencies -->
<script src="https://unpkg.com/fit-file-parser@1.11.0/dist/fit-file-parser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
// Minimal helpers (safe even if you also define these elsewhere)
const byId = (id) => document.getElementById(id);
const log = (el, msg) => { if(!el) return; el.textContent += msg + "\n"; el.scrollTop = el.scrollHeight; };
function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}
function rename(name, newExt){ return name.replace(/\.[^.]+$/, '') + '.' + newExt; }

// Year (if you haven’t set it elsewhere)
const yEl = byId('year'); if(yEl) yEl.textContent = new Date().getFullYear();

// ---------- GPS → CSV/XLSX ----------
const gpsLog = byId("gps-log");
const gpsBtnCsv = byId("gps-to-csv");
const gpsBtnXlsx = byId("gps-to-xlsx");
if (gpsBtnCsv) {
  gpsBtnCsv.addEventListener("click", async () => { await handleGpsExport("csv"); });
  gpsBtnXlsx.addEventListener("click", async () => { await handleGpsExport("xlsx"); });
}

async function handleGpsExport(kind){
  const files = Array.from((byId("gps-input")||{}).files||[]);
  if(!files.length) return alert("Pick one or more GPX/KML/TCX/FIT files");
  if(gpsLog) gpsLog.textContent = "";
  const rows = [];
  for(const f of files){
    try{
      const recs = await parseGpsFile(f);
      rows.push(...recs);
      log(gpsLog, `✓ Parsed ${f.name} (${recs.length} point(s))`);
    }catch(e){
      console.error(e); log(gpsLog, `✗ ${f.name}: ${e.message}`);
    }
  }
  if(!rows.length){ log(gpsLog, "No points found."); return; }

  if(kind==="csv"){
    const header = Object.keys(rows[0]);
    const csv = [header.join(","), ...rows.map(r => header.map(h => csvEscape(r[h])).join(","))].join("\n");
    downloadBlob(new Blob([csv], {type:"text/csv"}), "gps_points.csv");
    log(gpsLog, "✓ gps_points.csv");
  }else{
    const ws = XLSX.utils.json_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Points");
    const out = XLSX.write(wb, {type:"array", bookType:"xlsx"});
    downloadBlob(new Blob([out], {type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"}), "gps_points.xlsx");
    log(gpsLog, "✓ gps_points.xlsx");
  }
}

function csvEscape(v){
  if(v==null) return "";
  const s = String(v);
  return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
}

async function parseGpsFile(file){
  const ext = file.name.split(".").pop().toLowerCase();
  if(ext==="gpx") return parseGpx(await file.text(), file.name);
  if(ext==="kml") return parseKml(await file.text(), file.name);
  if(ext==="tcx") return parseTcx(await file.text(), file.name);
  if(ext==="fit") return await parseFit(await file.arrayBuffer(), file.name);
  const text = await file.text();
  if(/^<gpx/i.test(text.trim())) return parseGpx(text, file.name);
  if(/<kml[\s>]/i.test(text)) return parseKml(text, file.name);
  if(/<TrainingCenterDatabase[\s>]/i.test(text)) return parseTcx(text, file.name);
  throw new Error("Unsupported GPS format");
}

function parseGpx(text, filename){
  const xml = new DOMParser().parseFromString(text, "application/xml");
  const out = [];
  const trks = xml.getElementsByTagName("trk");
  for(let t=0;t<trks.length;t++){
    const trk = trks[t];
    const name = (trk.getElementsByTagName("name")[0]||{}).textContent||"";
    const segs = trk.getElementsByTagName("trkseg");
    for(let s=0;s<segs.length;s++){
      const pts = segs[s].getElementsByTagName("trkpt");
      for(let i=0;i<pts.length;i++){
        const p = pts[i];
        out.push({
          source: filename, type: "track", name,
          segment: s+1, index: i+1,
          lat: +p.getAttribute("lat"),
          lon: +p.getAttribute("lon"),
          ele: +((p.getElementsByTagName("ele")[0]||{}).textContent||"")||"",
          time: (p.getElementsByTagName("time")[0]||{}).textContent||""
        });
      }
    }
  }
  const wpts = xml.getElementsByTagName("wpt");
  for(let i=0;i<wpts.length;i++){
    const p = wpts[i];
    out.push({
      source: filename, type: "waypoint",
      name: (p.getElementsByTagName("name")[0]||{}).textContent||"",
      segment: "", index: i+1,
      lat: +p.getAttribute("lat"),
      lon: +p.getAttribute("lon"),
      ele: +((p.getElementsByTagName("ele")[0]||{}).textContent||"")||"",
      time: (p.getElementsByTagName("time")[0]||{}).textContent||""
    });
  }
  return out;
}

function parseKml(text, filename){
  const xml = new DOMParser().parseFromString(text, "application/xml");
  const out = [];
  const placemarks = Array.from(xml.getElementsByTagName("Placemark"));
  for(const pm of placemarks){
    const name = (pm.getElementsByTagName("name")[0]||{}).textContent||"";
    const lines = pm.getElementsByTagName("LineString");
    for(let l=0;l<lines.length;l++){
      const coords = (lines[l].getElementsByTagName("coordinates")[0]||{}).textContent||"";
      const pts = coords.trim().split(/\s+/).map(s=>s.split(",").map(Number)); // lon,lat[,alt]
      pts.forEach((c, i)=>{
        out.push({
          source: filename, type: "path", name,
          segment: l+1, index: i+1,
          lat: c[1], lon: c[0], ele: c[2]||"", time: ""
        });
      });
    }
    const points = pm.getElementsByTagName("Point");
    for(let p=0;p<points.length;p++){
      const c = ((points[p].getElementsByTagName("coordinates")[0]||{}).textContent||"").split(",").map(Number);
      if(c.length>=2){
        out.push({ source: filename, type:"point", name, segment:"", index: out.length+1, lat:c[1], lon:c[0], ele:c[2]||"", time:"" });
      }
    }
  }
  return out;
}

function parseTcx(text, filename){
  const xml = new DOMParser().parseFromString(text, "application/xml");
  const out = [];
  const tracks = Array.from(xml.getElementsByTagName("Track"));
  tracks.forEach((tr, sIdx)=>{
    const pts = Array.from(tr.getElementsByTagName("Trackpoint"));
    pts.forEach((tp, i)=>{
      const pos = tp.getElementsByTagName("Position")[0];
      const lat = pos ? +(pos.getElementsByTagName("LatitudeDegrees")[0]||{}).textContent : "";
      const lon = pos ? +(pos.getElementsByTagName("LongitudeDegrees")[0]||{}).textContent : "";
      const ele = +((tp.getElementsByTagName("AltitudeMeters")[0]||{}).textContent||"")||"";
      const time = (tp.getElementsByTagName("Time")[0]||{}).textContent||"";
      out.push({ source: filename, type:"track", name:"", segment:sIdx+1, index:i+1, lat, lon, ele, time });
    });
  });
  return out;
}

async function parseFit(buffer, filename){
  if(typeof FitParser === "undefined"){ throw new Error("FIT support not loaded"); }
  return new Promise((resolve, reject)=>{
    const parser = new FitParser({ force: true, elapsedRecordField: true });
    parser.parse(buffer, (err, data)=>{
      if(err) return reject(err);
      const recs = (data.records||[]).map((r,i)=>({
        source: filename,
        type: "record",
        name: data.activity && data.activity.sessions && data.activity.sessions[0] && data.activity.sessions[0].sport || "",
        segment: "",
        index: i+1,
        lat: (r.position_lat!=null) ? r.position_lat/1e7 : "",
        lon: (r.position_long!=null) ? r.position_long/1e7 : "",
        ele: r.altitude||"",
        time: r.timestamp||""
      }));
      resolve(recs);
    });
  });
}
</script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
const tabularLog = byId("tabular-log");
const tabularBtn = byId("tabular-export");
if(tabularBtn){
  tabularBtn.addEventListener("click", async ()=>{
    const f = byId("tabular-input").files[0]; if(!f) return alert("Pick a CSV or XLSX file");
    const target = byId("tabular-target").value; if(tabularLog) tabularLog.textContent = "";
    try{
      const rows = await readTableFromFile(f);
      if(!rows.length) throw new Error("No rows found");
      const cols = detectColumns(Object.keys(rows[0]||{}));
      if(!cols.lat || !cols.lon) throw new Error("Could not detect latitude/longitude columns");
      let text, ext;
      if(target==="gpx"){ text = toGPX(rows, cols, f.name); ext="gpx"; }
      else if(target==="kml"){ text = toKML(rows, cols, f.name); ext="kml"; }
      else { text = toTCX(rows, cols, f.name); ext="tcx"; }
      downloadBlob(new Blob([text], {type:"application/xml"}), f.name.replace(/\.[^.]+$/, "."+ext));
      log(tabularLog, `✓ Exported ${ext.toUpperCase()} with ${rows.length} point(s)`);
    }catch(e){ console.error(e); log(tabularLog, `✗ ${e.message}`); }
  });
}

async function readTableFromFile(file){
  const ext = file.name.split(".").pop().toLowerCase();
  if(ext==="csv" || file.type==="text/csv"){
    const text = await file.text();
    const parsed = Papa.parse(text, {header:true, skipEmptyLines:true});
    return parsed.data;
  }
  if(ext==="xlsx" || /sheet/.test(file.type)){
    const data = new Uint8Array(await file.arrayBuffer());
    const wb = XLSX.read(data, {type:"array"});
    const first = wb.SheetNames[0];
    return XLSX.utils.sheet_to_json(wb.Sheets[first], {defval:""});
  }
  throw new Error("Unsupported table format");
}

function norm(s){ return (s||"").toString().trim().toLowerCase(); }
function detectColumns(headers){
  const h = headers.map(norm);
  const find = (cands)=>{ for(const c of cands){ const i=h.findIndex(x=>x===c||x.includes(c)); if(i!==-1) return headers[i]; } return null; };
  return {
    lat: find(["latitude","lat","y","lat_deg"]),
    lon: find(["longitude","lon","lng","x","long","lon_deg"]),
    ele: find(["elevation","ele","altitude","alt","z"]),
    time: find(["time","timestamp","datetime","date"]),
    name: find(["name","title","label","id"])
  };
}
function xmlEsc(s){ return String(s==null?"":s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function toISO(t){ if(!t) return ""; const d=(t instanceof Date)?t:new Date(t); return isNaN(+d)?"":d.toISOString(); }

function toGPX(rows, cols, filename){
  const name = filename.replace(/\.[^.]+$/,"");
  const head = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="AnyConvert" xmlns="http://www.topografix.com/GPX/1/1">\n  <trk>\n    <name>${xmlEsc(name)}</name>\n    <trkseg>`;
  const body = rows.map(r=>{
    const lat=r[cols.lat], lon=r[cols.lon]; if(lat===""||lon==="") return "";
    const ele=cols.ele?r[cols.ele]:""; const time=cols.time?toISO(r[cols.time]):"";
    return `\n      <trkpt lat="${xmlEsc(lat)}" lon="${xmlEsc(lon)}">${ele!==""?`<ele>${xmlEsc(ele)}</ele>`:""}${time?`<time>${xmlEsc(time)}</time>`:""}</trkpt>`;
  }).join("");
  return head+body+`\n    </trkseg>\n  </trk>\n</gpx>`;
}

function toKML(rows, cols, filename){
  const name = filename.replace(/\.[^.]+$/,"");
  const head = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n  <Document>\n    <name>${xmlEsc(name)}</name>\n    <Placemark>\n      <name>${xmlEsc(name)}</name>\n      <LineString>\n        <coordinates>`;
  const coords = rows.map(r=>{
    const lat=r[cols.lat], lon=r[cols.lon]; if(lat===""||lon==="") return "";
    const ele=cols.ele?r[cols.ele]:""; return `${xmlEsc(lon)},${xmlEsc(lat)}${ele!==""?","+xmlEsc(ele):""}`;
  }).filter(Boolean).join(" ");
  const mid = `</coordinates>\n      </LineString>\n    </Placemark>`;
  const pts = rows.map((r,i)=>{
    const lat=r[cols.lat], lon=r[cols.lon]; if(lat===""||lon==="") return "";
    const nm=cols.name?r[cols.name]:`Pt ${i+1}`;
    return `\n    <Placemark><name>${xmlEsc(nm)}</name><Point><coordinates>${xmlEsc(lon)},${xmlEsc(lat)}</coordinates></Point></Placemark>`;
  }).join("");
  return head+coords+mid+pts+`\n  </Document>\n</kml>`;
}

function toTCX(rows, cols, filename){
  const name = filename.replace(/\.[^.]+$/,"");
  const head = `<?xml version="1.0" encoding="UTF-8"?>\n<TrainingCenterDatabase xmlns="http://www.garmin.com/xmlschemas/TrainingCenterDatabase/v2">\n  <Activities>\n    <Activity Sport="Other">\n      <Id>${toISO(rows[0]?.[cols.time])||new Date().toISOString()}</Id>\n      <Lap StartTime="${toISO(rows[0]?.[cols.time])||new Date().toISOString()}">\n        <Track>`;
  const body = rows.map(r=>{
    const lat=r[cols.lat], lon=r[cols.lon]; if(lat===""||lon==="") return "";
    const ele=cols.ele?r[cols.ele]:""; const time=cols.time?toISO(r[cols.time]):"";
    return `\n          <Trackpoint>${time?`<Time>${xmlEsc(time)}</Time>`:""}<Position><LatitudeDegrees>${xmlEsc(lat)}</LatitudeDegrees><LongitudeDegrees>${xmlEsc(lon)}</LongitudeDegrees></Position>${ele!==""?`<AltitudeMeters>${xmlEsc(ele)}</AltitudeMeters>`:""}</Trackpoint>`;
  }).join("");
  return head+body+`\n        </Track>\n      </Lap>\n    </Activity>\n  </Activities>\n</TrainingCenterDatabase>`;
}
</script>
<script>
/* ========== Helpers (safe to reuse if already declared) ========== */
(function(){
  const $ = (sel) => document.querySelector(sel);
  const byId = (id) => document.getElementById(id);

  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
  }
  function escapeHtml(v){
    const s = String(v ?? "");
    return s.replace(/[&<>"]/g, m => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[m]));
  }
  function toPreviewTable(rows){
    if(!rows || !rows.length) return "<em>No rows</em>";
    const keys = Object.keys(rows[0]);
    const head = `<tr>${keys.map(k=>`<th>${escapeHtml(k)}</th>`).join("")}</tr>`;
    const body = rows.slice(0,200).map(r=>`<tr>${keys.map(k=>`<td>${escapeHtml(r?.[k] ?? "")}</td>`).join("")}</tr>`).join("");
    return `<table class="preview-table">${head}${body}</table>`;
  }

  /* ========== JSON → CSV (preview + export) ========== */
  const jsonLog = byId("json-log");
  const jsonPreviewBox = byId("json-preview-area");
  const stringifyRestEl = byId("json-stringify-nonprim");
  const explodeArrEl = byId("json-explode-arr");

  function log(el, msg){ if(!el) return; el.textContent += msg + "\n"; el.scrollTop = el.scrollHeight; }

  async function loadJsonInput(){
    const f = byId("json-file")?.files?.[0];
    const text = f ? await f.text() : byId("json-input")?.value?.trim();
    if(!text) throw new Error("Provide JSON text or file");
    const parsed = JSON.parse(text);
    return Array.isArray(parsed) ? parsed : [parsed];
  }

  function flattenObjectDeep(obj, opts={stringifyRest:true}, prefix=""){
    if(obj == null) return obj;
    if(Array.isArray(obj)) return opts.stringifyRest ? JSON.stringify(obj) : obj;
    if(typeof obj !== "object") return obj;
    const out = {};
    for(const [k,v] of Object.entries(obj)){
      const key = prefix ? `${prefix}.${k}` : k;
      if(v && typeof v === "object" && !Array.isArray(v)){
        Object.assign(out, flattenObjectDeep(v, opts, key));
      } else {
        out[key] = (Array.isArray(v) && opts.stringifyRest) ? JSON.stringify(v) : v;
      }
    }
    return out;
  }

  function stringifyNonPrimitives(row){
    const out = {};
    for(const [k,v] of Object.entries(row)){
      out[k] = (v != null && typeof v === "object") ? JSON.stringify(v) : v;
    }
    return out;
  }

  function explodeArrays(rows){
    if(!rows.length) return rows;
    // pick the first key that has an Array in the first row
    const keys = Object.keys(rows[0]);
    const arrKey = keys.find(k => Array.isArray(rows[0][k]));
    if(!arrKey) return rows.map(stringifyNonPrimitives);

    const out = [];
    for(const r of rows){
      const arr = Array.isArray(r[arrKey]) ? r[arrKey] : [r[arrKey]];
      if(!Array.isArray(arr)){ out.push(stringifyNonPrimitives(r)); continue; }
      for(const item of arr){
        const dup = {...r, [arrKey]: (item!=null && typeof item==='object') ? JSON.stringify(item) : item};
        out.push(stringifyNonPrimitives(dup));
      }
    }
    return out;
  }

  function runJsonToCsv(preview){
    if(!byId("json-to-csv")) return; // panel may not be present
    jsonLog.textContent = "";
    loadJsonInput().then(rows => {
      if(!Array.isArray(rows)) throw new Error("Root must be an array of objects");
      const stringifyRest = !!stringifyRestEl?.checked;
      const explode = !!explodeArrEl?.checked;

      const flattened = rows.map(r => flattenObjectDeep(r, {stringifyRest}));
      const finalRows = explode ? explodeArrays(flattened) : flattened.map(stringifyNonPrimitives);

      if(preview){
        jsonPreviewBox.innerHTML = toPreviewTable(finalRows);
        jsonPreviewBox.classList.remove("hidden");
      }else{
        const csv = Papa.unparse(finalRows, {quotes:false});
        downloadBlob(new Blob([csv], {type:"text/csv"}), "data.csv");
        log(jsonLog, `✓ Exported data.csv (${finalRows.length} row(s))`);
      }
    }).catch(e => log(jsonLog, `✗ ${e.message}`));
  }

  byId("json-preview")?.addEventListener("click", ()=> runJsonToCsv(true));
  byId("json-to-csv")?.addEventListener("click", ()=> runJsonToCsv(false));

  /* ========== CSV → JSON (preview + export) ========== */
  const csvLog = byId("csv-log");
  const csvPreview = byId("csv-preview-area");

  function handleCsv(preview){
    csvLog.textContent = "";
    const f = byId("csv-file")?.files?.[0];
    if(!f){ alert("Pick a CSV file"); return; }
    f.text().then(text=>{
      const parsed = Papa.parse(text, {header:true, skipEmptyLines:true});
      if(parsed.errors?.length){ log(csvLog, `! Parser warnings: ${parsed.errors.length}`); }
      const rows = parsed.data || [];
      if(preview){
        csvPreview.innerHTML = toPreviewTable(rows);
        csvPreview.classList.remove("hidden");
      }else{
        const json = JSON.stringify(rows, null, 2);
        downloadBlob(new Blob([json],{type:"application/json"}), f.name.replace(/\.csv$/i, "_rows.json"));
        log(csvLog, `✓ Exported ${rows.length} JSON row(s)`);
      }
    }).catch(e=> log(csvLog, `✗ ${e.message}`));
  }

  byId("csv-preview")?.addEventListener("click", ()=> handleCsv(true));
  byId("csv-to-json")?.addEventListener("click", ()=> handleCsv(false));

  /* ========== JSON → DOCX (preview + export) ========== */
  const jsondocLog = byId("jsondoc-log");
  const jsondocPrev = byId("jsondoc-preview-box");

  function renderJsonToHtml(rows, mode, title){
    const keys = [...rows.reduce((s,r)=>{ Object.keys(r||{}).forEach(k=>s.add(k)); return s; }, new Set())];
    const css = "table{border-collapse:collapse;width:100%}th,td{border:1px solid #ddd;padding:6px;font-size:12px}th{background:#f2f2f2;text-align:left}";
    let body = title?`<h2>${escapeHtml(title)}</h2>`:"";
    if(mode==='table'){
      body += `<table><thead><tr>${keys.map(k=>`<th>${escapeHtml(k)}</th>`).join('')}</tr></thead><tbody>` +
              rows.map(r=>`<tr>${keys.map(k=>`<td>${escapeHtml(r?.[k] ?? '')}</td>`).join('')}</tr>`).join('') +
              `</tbody></table>`;
    } else {
      body += rows.map((r,i)=>`<h4>Item ${i+1}</h4><ul>${Object.entries(r||{}).map(([k,v])=>`<li><strong>${escapeHtml(k)}:</strong> ${escapeHtml(v)}</li>`).join('')}</ul>`).join('');
    }
    return `<!doctype html><html><head><meta charset="utf-8"><style>${css}</style></head><body>${body}</body></html>`;
  }

  async function buildJsonDocx(preview){
    jsondocLog.textContent = "";
    const file = byId("jsondoc-file")?.files?.[0];
    const text = file ? await file.text() : byId("jsondoc-input")?.value?.trim();
    if(!text){ log(jsondocLog, "Provide JSON text or file"); return; }

    let rows;
    try{
      const parsed = JSON.parse(text);
      rows = Array.isArray(parsed) ? parsed : [parsed];
    }catch(e){
      log(jsondocLog, `✗ Invalid JSON: ${e.message}`); return;
    }

    const mode = byId("jsondoc-mode")?.value || "table";
    const title = byId("jsondoc-title")?.value?.trim() || "";
    const html = renderJsonToHtml(rows, mode, title);

    jsondocPrev.innerHTML = html;
    jsondocPrev.classList.remove("hidden");

    if(!preview){
      try{
        const blob = window.htmlDocx.asBlob(html, {orientation:"portrait", margins:{top:720,right:720,bottom:720,left:720}});
        downloadBlob(blob, "data.docx");
        log(jsondocLog, "✓ Downloaded data.docx");
      }catch(e){
        log(jsondocLog, `✗ ${e.message}`);
      }
    }
  }

  byId("jsondoc-preview")?.addEventListener("click", ()=> buildJsonDocx(true));
  byId("jsondoc-docx")?.addEventListener("click", ()=> buildJsonDocx(false));

  /* ========== DOCX → HTML/TXT/JSON (preview + export) ========== */
  const docxLog = byId("docx-log");
  const docxPrev = byId("docx-html-preview");
  const btnHtml = byId("docx-dl-html");
  const btnTxt = byId("docx-dl-txt");
  const btnJson = byId("docx-extract-json");
  let lastHtml = "";

  function extractJsonFromHtml(html){
    const div = document.createElement("div"); div.innerHTML = html;
    const table = div.querySelector("table");
    if(table){
      const rows = Array.from(table.querySelectorAll("tr"));
      if(!rows.length) return [];
      const headers = Array.from(rows[0].querySelectorAll("th,td")).map(th=>th.textContent.trim());
      return rows.slice(1).map(tr=>{
        const cells = Array.from(tr.querySelectorAll("td,th"));
        const obj = {};
        headers.forEach((h,i)=> obj[h||`col${i+1}`] = (cells[i]?.textContent||"").trim());
        return obj;
      });
    }
    // Fallback: key: value lines
    const lines = Array.from(div.querySelectorAll("p,li")).map(e=>e.textContent.trim()).filter(Boolean);
    const obj = {};
    for(const line of lines){
      const m = line.match(/^([^:]+):\s*(.*)$/);
      if(m){ obj[m[1].trim()] = m[2].trim(); }
    }
    return Object.keys(obj).length ? obj : { text: div.textContent.trim() };
  }

  byId("docx-to-html")?.addEventListener("click", async ()=>{
    docxLog.textContent = "Converting…\n";
    const f = byId("docx-in")?.files?.[0];
    if(!f){ alert("Pick a .docx file"); return; }
    try{
      const arr = await f.arrayBuffer();
      const res = await window.mammoth.convertToHtml({arrayBuffer:arr});
      lastHtml = res.value || "";
      docxPrev.innerHTML = lastHtml || "<em>No content</em>";
      docxPrev.classList.remove("hidden");
      if(btnHtml) btnHtml.disabled = false;
      if(btnTxt) btnTxt.disabled = false;
      if(btnJson) btnJson.disabled = false;
      log(docxLog, `✓ Rendered HTML (${(lastHtml||"").length} chars)`);
    }catch(e){
      log(docxLog, `✗ ${e.message}`);
    }
  });

  btnHtml?.addEventListener("click", ()=>{ if(!lastHtml) return; downloadBlob(new Blob([lastHtml],{type:"text/html"}), "document.html"); });
  btnTxt?.addEventListener("click", ()=>{ if(!lastHtml) return; const tmp = lastHtml.replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim(); downloadBlob(new Blob([tmp],{type:"text/plain"}), "document.txt"); });
  btnJson?.addEventListener("click", ()=>{
    if(!lastHtml) return;
    const json = extractJsonFromHtml(lastHtml);
    downloadBlob(new Blob([JSON.stringify(json, null, 2)],{type:"application/json"}), "document.json");
    const count = Array.isArray(json) ? json.length : Object.keys(json||{}).length;
    log(docxLog, `✓ Extracted ${count} item(s) to JSON`);
  });

})();
</script>

</body>
</html>
