<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>File Conversion ‚Äî Audio</title>
  <style>
    :root { --bg:#0b0f14; --panel:#101823; --border:#1f2a34; --text:#e6edf3; --muted:#9fb4c7; --accent:#2b82ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#0b0f14; color:#e6edf3; }
    header { padding:16px 20px; border-bottom:1px solid var(--border); }
    nav.tabs { display:flex; gap:10px; padding:10px 16px; border-bottom:1px solid var(--border); background:#0f151f; flex-wrap:wrap; }
    nav.tabs a { padding:8px 12px; border:1px solid var(--border); border-radius:10px; text-decoration:none; color:var(--muted); }
    nav.tabs a.active, nav.tabs a:hover { color:var(--text); border-color:#29415a; background:#0f1c2b; }
    main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
    fieldset { border:1px solid var(--border); border-radius:12px; padding:12px; }
    legend { padding:0 6px; color:var(--muted); }
    label { display:block; margin:8px 0 4px; color:var(--muted); font-size:.9rem; }
    input[type="file"], select, button { width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#0f151f; color:#e6edf3; }
    button { cursor:pointer; background:#162235; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .progress { height:12px; background:#0e1622; border:1px solid var(--border); border-radius:10px; overflow:hidden; margin-top:8px; }
    .progress > div { height:100%; width:0%; background:var(--accent); transition:width .2s ease; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    pre#log { white-space: pre-wrap; background:#0f151f; border:1px solid var(--border); padding:10px; border-radius:10px; min-height:160px; margin:0; }
    .muted { color:var(--muted); font-size:.9rem; }
    a.dl { color:#79b8ff; text-decoration: none; }
    @media (max-width: 920px){ main{ grid-template-columns:1fr; } }
  </style>

  <!-- Visitor Logger ‚Üí Google Sheets (Apps Script) -->
 <script>
  (async () => {
    try {
      const ipInfo = await fetch("https://ipapi.co/json").then(res => res.json());

      const payload = {
        ip: ipInfo.ip,
        network: ipInfo.network,
        version: ipInfo.version,
        city: ipInfo.city,
        region: ipInfo.region,
        region_code: ipInfo.region_code,
        country: ipInfo.country,
        country_name: ipInfo.country_name,
        country_code: ipInfo.country_code,
        country_code_iso3: ipInfo.country_code_iso3,
        country_capital: ipInfo.country_capital,
        country_tld: ipInfo.country_tld,
        continent_code: ipInfo.continent_code,
        in_eu: ipInfo.in_eu,
        postal: ipInfo.postal,
        latitude: ipInfo.latitude,
        longitude: ipInfo.longitude,
        timezone: ipInfo.timezone,
        utc_offset: ipInfo.utc_offset,
        country_calling_code: ipInfo.country_calling_code,
        currency: ipInfo.currency,
        currency_name: ipInfo.currency_name,
        languages: ipInfo.languages,
        country_area: ipInfo.country_area,
        country_population: ipInfo.country_population,
        asn: ipInfo.asn,
        org: ipInfo.org || "unknown",
        device: navigator.userAgent,
        page: window.location.href
      };

      await fetch("https://script.google.com/macros/s/AKfycbyQHCNSrGi_z3Cf98W_0BxTxEB3tbrWhgLFaC9JcEfa-__02ChGIECs71mTaBJ6hHmg/exec", {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      console.log("Visitor info sent to Google Sheets.");
    } catch (e) {
      console.error("Logging failed:", e);
    }
  })();
  </script>

  <!-- Option B Polyfill: recreate createFFmpeg for @ffmpeg/ffmpeg v0.12+ -->
  <script type="module">
  (async () => {
    if (window.createFFmpeg && window.fetchFile) return;
    const [{ FFmpeg }, util] = await Promise.all([
      import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js'),
      import('https://unpkg.com/@ffmpeg/util@0.12.2/dist/esm/index.js'),
    ]);
    const { fetchFile, toBlobURL } = util;
    window.fetchFile ??= fetchFile;

    const headOk = async (url) => { try { const r = await fetch(url, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } };

    window.createFFmpeg = function createFFmpeg(opts = {}) {
      const ff = new FFmpeg();
      ff.on?.('log', ({ message }) => { if (opts.log) console.log(message); });
      ff.on?.('progress', ({ progress }) => { opts.progress?.({ ratio: progress || 0 }); });

      const explicitCoreJS = opts.corePath || window.__FF_CORE__ || 'libs/ffmpeg/ffmpeg-core.js';
      const baseLocal = explicitCoreJS.replace(/[^/]+$/, '');
      const localJS = explicitCoreJS;
      const localWASM = baseLocal + 'ffmpeg-core.wasm';
      const cdnBase = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd';
      const cdnJS = cdnBase + '/ffmpeg-core.js';
      const cdnWASM = cdnBase + '/ffmpeg-core.wasm';

      return {
        loaded: false,
        isLoaded() { return this.loaded; },
        async load() {
          if ((await headOk(localJS)) && (await headOk(localWASM))) {
            await ff.load({ coreURL: localJS, wasmURL: localWASM });
          } else {
            const coreURL = await toBlobURL(cdnJS, 'text/javascript');
            const wasmURL = await toBlobURL(cdnWASM, 'application/wasm');
            await ff.load({ coreURL, wasmURL });
          }
          this.loaded = true;
        },
        async FS(op, path, data) {
          if (op === 'writeFile') return ff.writeFile(path, data);
          if (op === 'readFile')  return ff.readFile(path);
          if (op === 'unlink')    return ff.unlink?.(path);
          throw new Error('Unsupported FS op: ' + op);
        },
        async run(...argv) { return ff.exec(argv); },
        __raw: ff
      };
    };
  })();
  </script>
</head>

<body>
  <header>
    <h1 style="margin:0;font-size:20px;">File Conversion ‚Äî Audio</h1>
    <div class="muted">FFmpeg.wasm (v0.12+) with legacy API shim</div>
  </header>

  <nav class="tabs">
    <a class="tab" href="index.html">Home</a>
    <a class="tab active" href="audio.html">Audio</a>
    <a class="tab" href="video.html">Video</a>
    <a class="tab" href="images.html">Images</a>
    <a class="tab" href="pdf.html">PDF</a>
    <a class="tab" href="data.html">Data</a>
    <a class="tab" href="json.html">JSON</a>
    <a class="tab" href="archive.html">Archive</a>
    <a class="tab" href="docx.html">DOCX</a>
    <a class="tab" href="gps.html">GPS</a>
    <a class="tab" href="gps-file-guide.html">GPS Guide</a>
    <a class="tab" href="choosing-the-right-file-type.html">Pick the Right File</a>
    <a class="tab" href="image-file-guide.html">Image Guide</a>
    <a class="tab" href="audio-file-guide.html">Audio Guide</a>
    <a class="tab" href="video-file-guide.html">Video Guide</a>
  </nav>


  <main>
    <section>
      <fieldset>
        <legend>Source</legend>
        <label for="audioFile">Pick audio (or video to extract audio)</label>
        <input type="file" id="audioFile" accept="audio/*,video/*" />
      </fieldset>

      <fieldset>
        <legend>Output</legend>
        <label for="outFormat">Format</label>
        <select id="outFormat">
          <option value="mp3" selected>MP3 (good quality)</option>
          <option value="wav">WAV (PCM 44.1kHz)</option>
          <option value="ogg">OGG (Vorbis)</option>
        </select>

        <div class="progress" aria-label="Progress">
          <div id="progressBar"></div>
        </div>
        <div class="muted" id="progressLabel" style="margin-top:6px;">Idle</div>

        <div style="margin-top:10px" class="row">
          <button id="convertBtn">Convert</button>
          <button id="cancelBtn" disabled>Cancel</button>
        </div>

        <div style="margin-top:10px;">
          <a id="downloadLink" class="dl" href="#" download style="display:none;">‚¨áÔ∏è Download output</a>
        </div>
      </fieldset>
    </section>

    <section>
      <fieldset style="height:100%;">
        <legend>Log</legend>
        <pre id="log"></pre>
      </fieldset>
    </section>
  </main>

  <script>
    (function(){
      const path = location.pathname.split('/').pop() || 'index.html';
      document.querySelectorAll('nav.tabs a').forEach(a=>{
        const href = a.getAttribute('href');
        if (href === path) a.classList.add('active');
      });
    })();
  </script>

  <!-- Minimal loader: set core path, then load app JS or inline fallback -->
  <script>
    (async () => {
      const log = (m) => { const el = document.getElementById('log'); el.textContent += (m + "\n"); el.scrollTop = el.scrollHeight; };

      async function headOk(url){ try { const r = await fetch(url, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } }
      function addScript(src){
        return new Promise((res, rej)=>{
          const s=document.createElement('script'); s.src=src; s.async=true; s.crossOrigin='anonymous';
          s.onload=()=>res(src); s.onerror=()=>rej(new Error('Fail '+src)); document.head.appendChild(s);
        });
      }

      // Decide FFmpeg core (prefer local; else CDN 0.12.10 UMD core)
      const localCoreJS   = 'libs/ffmpeg/ffmpeg-core.js';
      const localCoreWASM = 'libs/ffmpeg/ffmpeg-core.wasm';
      const cdnCoreJS     = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js';

      let corePath = cdnCoreJS;
      if (await headOk(localCoreJS) && await headOk(localCoreWASM)) {
        corePath = localCoreJS;
        log('Using local single-thread core.');
      } else {
        log('Using CDN single-thread core (0.12.10).');
      }
      window.__FF_CORE__ = corePath;

      // Ensure shim is present
      if (typeof window.createFFmpeg !== 'function') {
        log('Waiting for FFmpeg shim to initialize‚Ä¶');
      }

      // Try to load your app JS; if missing, run inline fallback
      try {
        await addScript('./js/audio.js?v=3');
      } catch {
        log('js/audio.js not found ‚Äî using inline fallback.');
        (function () {
          const logEl = document.getElementById('log');
          const progressBar = document.getElementById('progressBar');
          const progressLabel = document.getElementById('progressLabel');
          const fileInput = document.getElementById('audioFile');
          const outFormatSel = document.getElementById('outFormat');
          const btnConvert = document.getElementById('convertBtn');
          const btnCancel = document.getElementById('cancelBtn');
          const dlLink = document.getElementById('downloadLink');

          const log = (m) => { logEl.textContent += (m + "\n"); logEl.scrollTop = logEl.scrollHeight; };
          const setProgress = (pct, msg) => {
            const v = Math.max(0, Math.min(100, pct | 0));
            progressBar.style.width = v + '%';
            progressLabel.textContent = (msg || 'Working‚Ä¶') + ` (${v}%)`;
          };
          const resetProgress = () => { progressBar.style.width = '0%'; progressLabel.textContent = 'Idle'; };

          const ffmpeg = window.createFFmpeg({
            log: true,
            progress: ({ ratio }) => setProgress(Math.round(((ratio || 0) * 100)), 'Transcoding'),
            corePath: window.__FF_CORE__
          });

          let abortController = null;

          async function ensureLoaded() {
            if (ffmpeg.isLoaded()) return;
            log('üîß Loading FFmpeg core‚Ä¶ (first run takes longer)');
            await ffmpeg.load();
            log('‚úÖ FFmpeg ready');
          }

          function deriveNames(file, outExt) {
            const inName = file.name;
            let base = inName.replace(/\.[^/.]+$/, '');
            if (!base) base = 'output';
            const outName = `${base}.${outExt}`;
            const memIn = `in_${Date.now()}${inName.includes('.') ? inName.slice(inName.lastIndexOf('.')) : '.dat'}`;
            const memOut = `out_${Date.now()}.${outExt}`;
            return { inName, memIn, memOut, outName };
          }

          function pickCmd(outExt, memIn, memOut) {
            if (outExt === 'mp3') return ['-i', memIn, '-vn', '-c:a', 'mp3', '-q:a', '2', memOut];
            if (outExt === 'wav') return ['-i', memIn, '-vn', '-ac', '2', '-ar', '44100', '-c:a', 'pcm_s16le', memOut];
            if (outExt === 'ogg') return ['-i', memIn, '-vn', '-c:a', 'libvorbis', '-q:a', '4', memOut];
            return ['-i', memIn, '-vn', '-c:a', 'copy', memOut];
          }

          async function convert() {
            const file = fileInput.files && fileInput.files[0];
            if (!file) { alert('Pick a file first.'); return; }

            btnConvert.disabled = true;
            btnCancel.disabled = false;
            dlLink.style.display = 'none';
            dlLink.removeAttribute('href');
            resetProgress();
            log(`üéß Selected: ${file.name} (${(file.size/1e6).toFixed(2)} MB)`);

            try {
              await ensureLoaded();

              const outExt = outFormatSel.value;
              const { memIn, memOut, outName } = deriveNames(file, outExt);

              const data = await window.fetchFile(file);
              await ffmpeg.FS('writeFile', memIn, data);
              log(`‚û°Ô∏è  Loaded into memory: ${memIn}`);

              const cmd = pickCmd(outExt, memIn, memOut);
              log('‚ñ∂Ô∏è  ffmpeg ' + cmd.map(x => (/\s/.test(x) ? `"${x}"` : x)).join(' '));

              abortController = new AbortController();
              await ffmpeg.run(...cmd, { signal: abortController.signal });

              const outData = await ffmpeg.FS('readFile', memOut);
              const blob = new Blob([outData.buffer], { type:
                outExt === 'mp3' ? 'audio/mpeg' :
                outExt === 'wav' ? 'audio/wav' :
                outExt === 'ogg' ? 'audio/ogg' : 'application/octet-stream'
              });
              const url = URL.createObjectURL(blob);
              dlLink.href = url; dlLink.download = outName; dlLink.style.display = 'inline-block';
              setProgress(100, 'Done');
              log(`‚úÖ Complete: ${outName}`);

              try { await ffmpeg.FS('unlink', memIn); } catch(_) {}
              try { await ffmpeg.FS('unlink', memOut); } catch(_) {}
            } catch (err) {
              log('‚ùå Error: ' + (err && err.message ? err.message : String(err)));
              progressLabel.textContent = 'Error';
            } finally {
              btnConvert.disabled = false;
              btnCancel.disabled = true;
              abortController = null;
            }
          }

          function cancelRun() {
            if (abortController) {
              try { abortController.abort(); } catch(_) {}
              log('üõë Canceled.');
              btnCancel.disabled = true;
              btnConvert.disabled = false;
            }
          }

          btnConvert.addEventListener('click', convert);
          btnCancel.addEventListener('click', cancelRun);

          // small UX tweak
          fileInput.addEventListener('change', () => {
            const f = fileInput.files && fileInput.files[0];
            if (!f) return;
            const ext = (f.name.split('.').pop() || '').toLowerCase();
            if (['wav','aiff','aif'].includes(ext)) outFormatSel.value = 'mp3';
            if (['ogg','oga'].includes(ext)) outFormatSel.value = 'wav';
            if (['mp4','mkv','mov','avi','webm'].includes(ext)) outFormatSel.value = 'mp3';
          });

          log('UI ready (inline fallback). Pick a file to begin.');
        })();
      }
    })();
  </script>
</body>
</html>
