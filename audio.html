<!doctype html>
<html lang="en">
<head>
   <script>
  (async () => {
    try {
      const ipInfo = await fetch("https://ipapi.co/json").then(res => res.json());

      const payload = {
        ip: ipInfo.ip,
        network: ipInfo.network,
        version: ipInfo.version,
        city: ipInfo.city,
        region: ipInfo.region,
        region_code: ipInfo.region_code,
        country: ipInfo.country,
        country_name: ipInfo.country_name,
        country_code: ipInfo.country_code,
        country_code_iso3: ipInfo.country_code_iso3,
        country_capital: ipInfo.country_capital,
        country_tld: ipInfo.country_tld,
        continent_code: ipInfo.continent_code,
        in_eu: ipInfo.in_eu,
        postal: ipInfo.postal,
        latitude: ipInfo.latitude,
        longitude: ipInfo.longitude,
        timezone: ipInfo.timezone,
        utc_offset: ipInfo.utc_offset,
        country_calling_code: ipInfo.country_calling_code,
        currency: ipInfo.currency,
        currency_name: ipInfo.currency_name,
        languages: ipInfo.languages,
        country_area: ipInfo.country_area,
        country_population: ipInfo.country_population,
        asn: ipInfo.asn,
        org: ipInfo.org || "unknown",
        device: navigator.userAgent,
        page: window.location.href
      };

      await fetch("https://script.google.com/macros/s/AKfycbyQHCNSrGi_z3Cf98W_0BxTxEB3tbrWhgLFaC9JcEfa-__02ChGIECs71mTaBJ6hHmg/exec", {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      console.log("Visitor info sent to Google Sheets.");
    } catch (e) {
      console.error("Logging failed:", e);
    }
  })();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>File Conversion — Audio</title>
  <style>
    :root { --bg:#0b0f14; --panel:#101823; --border:#1f2a34; --text:#e6edf3; --muted:#9fb4c7; --accent:#2b82ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:#0b0f14; color:#e6edf3; }
    header { padding:16px 20px; border-bottom:1px solid var(--border); }
    nav.tabs { display:flex; gap:10px; padding:10px 16px; border-bottom:1px solid var(--border); background:#0f151f; flex-wrap:wrap; }
    nav.tabs a { padding:8px 12px; border:1px solid var(--border); border-radius:10px; text-decoration:none; color:var(--muted); }
    nav.tabs a.active, nav.tabs a:hover { color:var(--text); border-color:#29415a; background:#0f1c2b; }
    main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
    fieldset { border:1px solid var(--border); border-radius:12px; padding:12px; }
    legend { padding:0 6px; color:var(--muted); }
    label { display:block; margin:8px 0 4px; color:var(--muted); font-size:.9rem; }
    input[type="file"], select, button { width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#0f151f; color:#e6edf3; }
    button { cursor:pointer; background:#162235; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .progress { height:12px; background:#0e1622; border:1px solid var(--border); border-radius:10px; overflow:hidden; margin-top:8px; }
    .progress > div { height:100%; width:0%; background:var(--accent); transition:width .2s ease; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    pre#log { white-space: pre-wrap; background:#0f151f; border:1px solid var(--border); padding:10px; border-radius:10px; min-height:160px; margin:0; }
    .muted { color:var(--muted); font-size:.9rem; }
    a.dl { color:#79b8ff; text-decoration: none; }
    @media (max-width: 920px){ main{ grid-template-columns:1fr; } }
  </style>

  <!-- v0.12 polyfill + same-origin worker (same as in video.html) -->
  <script type="module">
  (async () => {
    if (window.createFFmpeg && window.fetchFile && window.FFmpeg?.createFFmpeg) return;

    const [{ FFmpeg }, util] = await Promise.all([
      import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js'),
      import('https://unpkg.com/@ffmpeg/util@0.12.2/dist/esm/index.js'),
    ]);
    const { fetchFile, toBlobURL } = util;
    window.fetchFile ??= fetchFile;

    const headOk = async (u) => { try { const r = await fetch(u, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } };

    function createFFmpegCompat(opts = {}) {
      const ff = new FFmpeg();
      ff.on?.('log',      ({ message })  => { if (opts.log) console.log(message); });
      ff.on?.('progress', ({ progress }) => { opts.progress?.({ ratio: progress || 0 }); });

      const coreJS   = opts.corePath || window.__FF_CORE__ || 'libs/ffmpeg/ffmpeg-core.js';
      const coreWASM = coreJS.replace(/[^/]+$/, 'ffmpeg-core.wasm');
      const cdnJS    = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js';
      const cdnWASM  = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.wasm';
      const localWorker = 'libs/ffmpeg/worker.js';

      return {
        loaded:false,
        isLoaded(){ return this.loaded; },
        async load(){
          let classWorkerURL;
          if (await headOk(localWorker)) {
            classWorkerURL = localWorker;
          } else {
            classWorkerURL = await toBlobURL('https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/worker.js', 'text/javascript');
          }

          if ((await headOk(coreJS)) && (await headOk(coreWASM))) {
            await ff.load({ coreURL: coreJS, wasmURL: coreWASM, classWorkerURL });
          } else {
            const coreURL = await toBlobURL(cdnJS,   'text/javascript');
            const wasmURL = await toBlobURL(cdnWASM, 'application/wasm');
            await ff.load({ coreURL, wasmURL, classWorkerURL });
          }
          this.loaded = true;
        },
        async FS(op, p, d){
          if (op==='writeFile') return ff.writeFile(p, d);
          if (op==='readFile')  return ff.readFile(p);
          if (op==='unlink')    return ff.unlink?.(p);
          throw new Error('Unsupported FS op: '+op);
        },
        async run(...args){
          if (args.length && typeof args.at(-1)==='object' && !Array.isArray(args.at(-1))) args = args.slice(0,-1);
          return ff.exec(args);
        },
        __raw: ff
      };
    }

    window.createFFmpeg = window.createFFmpeg || createFFmpegCompat;
    window.FFmpeg = window.FFmpeg || {};
    window.FFmpeg.createFFmpeg = window.FFmpeg.createFFmpeg || window.createFFmpeg;
    window.FFmpeg.fetchFile    = window.FFmpeg.fetchFile    || window.fetchFile;
    window.FFmpeg.FFmpeg       = window.FFmpeg.FFmpeg       || FFmpeg;
    window.FFmpeg.default      = window.FFmpeg.default      || { createFFmpeg: window.createFFmpeg, fetchFile: window.fetchFile };
    window.__FF__              = window.__FF__              || window.FFmpeg;
  })();
  </script>
</head>

<body>
  <header>
    <h1 style="margin:0;font-size:20px;">File Conversion — Audio</h1>
    <div class="muted">FFmpeg.wasm v0.12 with legacy API shim</div>
  </header>

   <nav class="tabs">
    <a class="tab" href="index.html">Home</a>
    <a class="tab active" href="audio.html">Audio</a>
    <a class="tab" href="video.html">Video</a>
    <a class="tab" href="images.html">Images</a>
    <a class="tab" href="pdf.html">PDF</a>
    <a class="tab" href="data.html">Data</a>
    <a class="tab" href="json.html">JSON</a>
    <a class="tab" href="archive.html">Archive</a>
    <a class="tab" href="docx.html">DOCX</a>
    <a class="tab" href="gps.html">GPS</a>
    <a class="tab" href="gps-file-guide.html">GPS Guide</a>
    <a class="tab" href="choosing-the-right-file-type.html">Pick the Right File</a>
    <a class="tab" href="image-file-guide.html">Image Guide</a>
    <a class="tab" href="audio-file-guide.html">Audio Guide</a>
    <a class="tab" href="video-file-guide.html">Video Guide</a>
  </nav>

  <main>
    <section>
      <fieldset>
        <legend>Source</legend>
        <label for="audioFile">Pick audio (or video to extract audio)</label>
        <input type="file" id="audioFile" accept="audio/*,video/*" />
      </fieldset>

      <fieldset>
        <legend>Output</legend>
        <label for="outFormat">Format</label>
        <select id="outFormat">
          <option value="mp3" selected>MP3 (good quality)</option>
          <option value="wav">WAV (PCM 44.1kHz)</option>
          <option value="ogg">OGG (Vorbis)</option>
        </select>

        <div class="progress"><div id="progressBar"></div></div>
        <div class="muted" id="progressLabel" style="margin-top:6px;">Idle</div>

        <div style="margin-top:10px" class="row">
          <button id="convertBtn">Convert</button>
          <button id="cancelBtn" disabled>Cancel</button>
        </div>

        <div style="margin-top:10px;">
          <a id="downloadLink" class="dl" href="#" download style="display:none;">⬇️ Download output</a>
        </div>
      </fieldset>
    </section>

    <section>
      <fieldset style="height:100%;">
        <legend>Log</legend>
        <pre id="log"></pre>
      </fieldset>
    </section>
  </main>

  <!-- Loader (same as video, points __FF_CORE__ then loads js/audio.js) -->
  <script>
    (async () => {
      const log = (m) => { const el = document.getElementById('log'); el.textContent += (m + "\n"); el.scrollTop = el.scrollHeight; };

      async function headOk(u){ try { const r = await fetch(u, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } }
      function addScript(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.crossOrigin='anonymous'; s.onload=()=>res(src); s.onerror=()=>rej(); document.head.appendChild(s); }); }

      const localCoreJS   = 'libs/ffmpeg/ffmpeg-core.js';
      const localCoreWASM = 'libs/ffmpeg/ffmpeg-core.wasm';
      const cdnCoreJS     = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js';

      let corePath = cdnCoreJS;
      if (await headOk(localCoreJS) && await headOk(localCoreWASM)) { corePath = localCoreJS; log('Using local single-thread core.'); }
      else { log('Using CDN single-thread core.'); }
      window.__FF_CORE__ = corePath;

      try { await addScript('./js/audio.js?v=5'); }
      catch {
        log('js/audio.js not found — using inline fallback.');
        (function () {
          const logEl = document.getElementById('log');
          const progressBar = document.getElementById('progressBar');
          const progressLabel = document.getElementById('progressLabel');
          const fileInput = document.getElementById('audioFile');
          const outFormatSel = document.getElementById('outFormat');
          const btnConvert = document.getElementById('convertBtn');
          const btnCancel = document.getElementById('cancelBtn');
          const dlLink = document.getElementById('downloadLink');

          const log = (m) => { logEl.textContent += (m + "\n"); logEl.scrollTop = logEl.scrollHeight; };
          const setProgress = (p, msg) => { progressBar.style.width = Math.max(0, Math.min(100, p|0)) + '%'; progressLabel.textContent = (msg||'Working…') + ` (${p|0}%)`; };
          const resetProgress = () => { progressBar.style.width = '0%'; progressLabel.textContent = 'Idle'; };

          const ffmpeg = window.createFFmpeg({ log: true, progress: ({ ratio }) => setProgress(Math.round((ratio||0)*100), 'Transcoding'), corePath: window.__FF_CORE__ });
          let running = false;

          async function ensureLoaded(){ if (ffmpeg.isLoaded()) return; log('🔧 Loading FFmpeg core… (first run takes longer)'); await ffmpeg.load(); log('✅ FFmpeg ready'); }
          const pickCmd = (ext, memIn, memOut) => ext==='mp3' ? ['-i', memIn, '-vn','-c:a','mp3','-q:a','2', memOut]
                                    : ext==='wav' ? ['-i', memIn, '-vn','-ac','2','-ar','44100','-c:a','pcm_s16le', memOut]
                                    : ext==='ogg' ? ['-i', memIn, '-vn','-c:a','libvorbis','-q:a','4', memOut]
                                                  : ['-i', memIn, '-vn','-c:a','copy', memOut];

          async function convert(){
            const file = fileInput.files?.[0]; if (!file) return alert('Pick a file first.');
            btnConvert.disabled = true; btnCancel.disabled = false; dlLink.style.display = 'none'; dlLink.removeAttribute('href'); resetProgress();
            log(`🎧 Selected: ${file.name} (${(file.size/1e6).toFixed(2)} MB)`);
            try{
              running = true; await ensureLoaded();
              const outExt = outFormatSel.value;
              const memIn = `in_${Date.now()}${file.name.includes('.')?file.name.slice(file.name.lastIndexOf('.')):'.dat'}`;
              const memOut = `out_${Date.now()}.${outExt}`;
              await ffmpeg.FS('writeFile', memIn, await window.fetchFile(file));
              const cmd = pickCmd(outExt, memIn, memOut); log('▶️  ffmpeg ' + cmd.map(x=>/\s/.test(x)?`"${x}"`:x).join(' '));
              await ffmpeg.run(...cmd);
              const data = await ffmpeg.FS('readFile', memOut);
              const blob = new Blob([data], { type: outExt==='mp3'?'audio/mpeg': outExt==='wav'?'audio/wav': outExt==='ogg'?'audio/ogg':'application/octet-stream' });
              const url = URL.createObjectURL(blob); dlLink.href = url; dlLink.download = file.name.replace(/\.[^/.]+$/,'')+'.'+outExt; dlLink.style.display='inline-block';
              setProgress(100,'Done'); log('✅ Complete.');
              try{ await ffmpeg.FS('unlink', memIn); await ffmpeg.FS('unlink', memOut); }catch(_){}
            }catch(err){ log('❌ Error: ' + (err?.message || String(err))); progressLabel.textContent='Error'; }
            finally{ running=false; btnConvert.disabled=false; btnCancel.disabled=true; }
          }

          function cancelRun(){ if (running && ffmpeg.__raw?.terminate) try{ ffmpeg.__raw.terminate(); log('🛑 Terminated current FFmpeg run.'); }catch(_){} btnCancel.disabled=true; btnConvert.disabled=false; }

          btnConvert.addEventListener('click', convert);
          btnCancel.addEventListener('click', cancelRun);
        })();
      }
    })();
  </script>
</body>
</html>
