<!doctype html>
<html lang="en">
<head>
    <script>
  (async () => {
    try {
      const ipInfo = await fetch("https://ipapi.co/json").then(res => res.json());

      const payload = {
        ip: ipInfo.ip,
        network: ipInfo.network,
        version: ipInfo.version,
        city: ipInfo.city,
        region: ipInfo.region,
        region_code: ipInfo.region_code,
        country: ipInfo.country,
        country_name: ipInfo.country_name,
        country_code: ipInfo.country_code,
        country_code_iso3: ipInfo.country_code_iso3,
        country_capital: ipInfo.country_capital,
        country_tld: ipInfo.country_tld,
        continent_code: ipInfo.continent_code,
        in_eu: ipInfo.in_eu,
        postal: ipInfo.postal,
        latitude: ipInfo.latitude,
        longitude: ipInfo.longitude,
        timezone: ipInfo.timezone,
        utc_offset: ipInfo.utc_offset,
        country_calling_code: ipInfo.country_calling_code,
        currency: ipInfo.currency,
        currency_name: ipInfo.currency_name,
        languages: ipInfo.languages,
        country_area: ipInfo.country_area,
        country_population: ipInfo.country_population,
        asn: ipInfo.asn,
        org: ipInfo.org || "unknown",
        device: navigator.userAgent,
        page: window.location.href
      };

      await fetch("https://script.google.com/macros/s/AKfycbyQHCNSrGi_z3Cf98W_0BxTxEB3tbrWhgLFaC9JcEfa-__02ChGIECs71mTaBJ6hHmg/exec", {
        method: "POST",
        mode: "no-cors",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      console.log("Visitor info sent to Google Sheets.");
    } catch (e) {
      console.error("Logging failed:", e);
    }
  })();
  </script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>File Conversion — Video</title>
  <style>
    :root { --bg:#0b0f14; --panel:#101823; --border:#1f2a34; --text:#e6edf3; --muted:#9fb4c7; --accent:#2b82ff; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 20px; border-bottom:1px solid var(--border); }
    nav.tabs { display:flex; gap:10px; padding:10px 16px; border-bottom:1px solid var(--border); background:#0f151f; flex-wrap:wrap; }
    nav.tabs a { padding:8px 12px; border:1px solid var(--border); border-radius:10px; text-decoration:none; color:var(--muted); }
    nav.tabs a.active, nav.tabs a:hover { color:var(--text); border-color:#29415a; background:#0f1c2b; }
    main { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
    fieldset { border:1px solid var(--border); border-radius:12px; padding:12px; }
    legend { padding:0 6px; color:var(--muted); }
    label { display:block; margin:8px 0 4px; color:var(--muted); font-size:.9rem; }
    input[type="file"], select, button { width:100%; padding:10px; border-radius:10px; border:1px solid var(--border); background:#0f151f; color:var(--text); }
    button { cursor:pointer; background:#162235; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .progress { height:12px; background:#0e1622; border:1px solid var(--border); border-radius:10px; overflow:hidden; margin-top:8px; }
    .progress > div { height:100%; width:0%; background:var(--accent); transition:width .2s ease; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    pre#log { white-space: pre-wrap; background:#0f151f; border:1px solid var(--border); padding:10px; border-radius:10px; min-height:180px; margin:0; }
    .muted { color:var(--muted); font-size:.9rem; }
    a.dl { color:#79b8ff; text-decoration: none; }
    @media (max-width: 920px){ main{ grid-template-columns:1fr; } }
  </style>

  <!-- Optional: visitor log to Google Sheets (replace URL to enable) -->
  <script>
    (async () => {
      const SHEET_WEB_APP_URL = "https://script.google.com/macros/s/REPLACE_WITH_YOURS/exec";
      if (!SHEET_WEB_APP_URL.includes("REPLACE_WITH_YOURS")) return;
      try {
        const ip = await fetch("https://ipapi.co/json").then(r=>r.json()).catch(()=> ({}));
        const body = { timestamp:new Date().toISOString(), ...ip, user_agent:navigator.userAgent, page:location.href, referrer:document.referrer||"" };
        await fetch(SHEET_WEB_APP_URL, { method:"POST", mode:"no-cors", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(body) });
      } catch(_) {}
    })();
  </script>

  <!-- FFmpeg v0.12 polyfill: ESM core + same-origin worker -->
  <script type="module">
  (async () => {
    if (window.createFFmpeg && window.fetchFile && window.FFmpeg?.createFFmpeg) return;

    const [{ FFmpeg }, util] = await Promise.all([
      import('https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js'),
      import('https://unpkg.com/@ffmpeg/util@0.12.2/dist/esm/index.js'),
    ]);
    const { fetchFile } = util;
    window.fetchFile ??= fetchFile;

    const headOk = async (u) => { try { const r = await fetch(u, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } };

    // Build a class worker URL:
    // 1) Use local same-origin worker (best).
    // 2) Else patch CDN worker imports to absolute URLs and blob-ify.
    async function getClassWorkerURL() {
      const local = 'libs/ffmpeg/worker.js';
      if (await headOk(local)) return local;
      const base = 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/esm/';
      const src  = base + 'worker.js';
      const code = await fetch(src, { cache:'no-store' }).then(r => r.text());
      const patched = code
        .replace(/from\s+['"]\.\/const\.js['"]/g,  `from '${base}const.js'`)
        .replace(/from\s+['"]\.\/errors\.js['"]/g, `from '${base}errors.js'`);
      return URL.createObjectURL(new Blob([patched], { type: 'text/javascript' }));
    }

    function createFFmpegCompat(opts = {}) {
      const ff = new FFmpeg();
      const pageLog = window.__FF_PAGE_LOG || null;

      ff.on?.('log',      ({ message })  => { if (opts.log) console.log(message); if (pageLog) pageLog('[ff] ' + message); });
      ff.on?.('progress', ({ progress }) => { opts.progress?.({ ratio: progress || 0 }); });

      // Prefer local ESM core (required for module worker), else CDN ESM
      const localESMJS   = 'libs/ffmpeg/esm/ffmpeg-core.js';
      const localESMWASM = 'libs/ffmpeg/esm/ffmpeg-core.wasm';
      const cdnESMJS     = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/esm/ffmpeg-core.js';
      const cdnESMWASM   = 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/esm/ffmpeg-core.wasm';

      return {
        loaded:false,
        isLoaded(){ return this.loaded; },
        async load(){
          const classWorkerURL = await getClassWorkerURL();

          let coreURL, wasmURL;
          if (await headOk(localESMJS) && await headOk(localESMWASM)) {
            coreURL = localESMJS;
            wasmURL = localESMWASM;
          } else {
            coreURL = cdnESMJS;
            wasmURL = cdnESMWASM;
          }

          await ff.load({ coreURL, wasmURL, classWorkerURL });
          this.loaded = true;
        },
        async FS(op, p, d){
          if (op==='writeFile') return ff.writeFile(p, d);
          if (op==='readFile')  return ff.readFile(p);
          if (op==='unlink')    return ff.unlink?.(p);
          throw new Error('Unsupported FS op: '+op);
        },
        async run(...args){
          if (args.length && typeof args.at(-1)==='object' && !Array.isArray(args.at(-1))) args = args.slice(0,-1);
          return ff.exec(args);
        },
        __raw: ff
      };
    }

    // Publish legacy-style globals
    window.createFFmpeg = window.createFFmpeg || createFFmpegCompat;
    window.FFmpeg = window.FFmpeg || {};
    window.FFmpeg.createFFmpeg = window.FFmpeg.createFFmpeg || window.createFFmpeg;
    window.FFmpeg.fetchFile    = window.FFmpeg.fetchFile    || window.fetchFile;
    window.FFmpeg.FFmpeg       = window.FFmpeg.FFmpeg       || FFmpeg;
    window.FFmpeg.default      = window.FFmpeg.default      || { createFFmpeg: window.createFFmpeg, fetchFile: window.fetchFile };
    window.__FF__              = window.__FF__              || window.FFmpeg;
  })();
  </script>
</head>

<body>
  <header>
    <h1 style="margin:0;font-size:20px;">File Conversion — Video</h1>
    <div class="muted">FFmpeg.wasm v0.12 (ESM core + same-origin worker, legacy API shim)</div>
  </header>

  <nav class="tabs">
    <a class="tab" href="index.html">Home</a>
    <a class="tab" href="audio.html">Audio</a>
    <a class="tab active" href="video.html">Video</a>
    <a class="tab" href="images.html">Images</a>
    <a class="tab" href="pdf.html">PDF</a>
    <a class="tab" href="data.html">Data</a>
    <a class="tab" href="json.html">JSON</a>
    <a class="tab" href="archive.html">Archive</a>
    <a class="tab" href="docx.html">DOCX</a>
    <a class="tab" href="gps.html">GPS</a>
    <a class="tab" href="gps-file-guide.html">GPS Guide</a>
    <a class="tab" href="choosing-the-right-file-type.html">Pick the Right File</a>
    <a class="tab" href="image-file-guide.html">Image Guide</a>
    <a class="tab" href="audio-file-guide.html">Audio Guide</a>
    <a class="tab" href="video-file-guide.html">Video Guide</a>
  </nav>

  <main>
    <section>
      <fieldset>
        <legend>Source</legend>
        <label for="videoFile">Pick a file</label>
        <input type="file" id="videoFile" accept="video/*,audio/*" />
      </fieldset>

      <fieldset>
        <legend>Output</legend>
        <label for="outFormat">Format</label>
        <select id="outFormat">
          <option value="mp4" selected>MP4 (remux, fast)</option>
          <option value="webm">WEBM (vp8/vorbis)</option>
          <option value="mp3">MP3 (audio only)</option>
        </select>

        <div class="progress"><div id="progressBar"></div></div>
        <div class="muted" id="progressLabel" style="margin-top:6px;">Idle</div>

        <div style="margin-top:10px" class="row">
          <button id="convertBtn">Convert</button>
          <button id="cancelBtn" disabled>Cancel</button>
        </div>

        <div style="margin-top:10px;">
          <a id="downloadLink" class="dl" href="#" download style="display:none;">⬇️ Download output</a>
        </div>
      </fieldset>
    </section>

    <section>
      <fieldset style="height:100%;">
        <legend>Log</legend>
        <pre id="log"></pre>
      </fieldset>
    </section>
  </main>

  <script>
    (function(){
      const path = location.pathname.split('/').pop() || 'index.html';
      document.querySelectorAll('nav.tabs a').forEach(a=>{
        if (a.getAttribute('href') === path) a.classList.add('active');
      });
    })();
  </script>

  <!-- Loader + animated load progress + timeout + inline fallback -->
  <script>
    (async () => {
      const logEl = document.getElementById('log');
      const progressBar = document.getElementById('progressBar');
      const progressLabel = document.getElementById('progressLabel');
      const fileInput = document.getElementById('videoFile');
      const outFormatSel = document.getElementById('outFormat');
      const btnConvert = document.getElementById('convertBtn');
      const btnCancel = document.getElementById('cancelBtn');
      const dlLink = document.getElementById('downloadLink');

      const log = (m) => { logEl.textContent += (m + "\n"); logEl.scrollTop = logEl.scrollHeight; };
      window.__FF_PAGE_LOG = (m) => log(m);

      const setProgress = (pct, msg) => {
        const v = Math.max(0, Math.min(100, pct | 0));
        progressBar.style.width = v + '%';
        progressLabel.textContent = (msg || 'Working…') + ` (${v}%)`;
      };
      const resetProgress = () => { progressBar.style.width = '0%'; progressLabel.textContent = 'Idle'; };

      async function headOk(u){ try { const r = await fetch(u, { method:'HEAD', cache:'no-store' }); return r.ok; } catch { return false; } }
      function addScript(src){
        return new Promise((res, rej)=>{
          const s=document.createElement('script'); s.src=src; s.async=true; s.crossOrigin='anonymous';
          s.onload=()=>res(src); s.onerror=()=>rej(new Error('Fail '+src)); document.head.appendChild(s);
        });
      }

      // Let the log reflect which core is present (informational)
      const localESMJS   = 'libs/ffmpeg/esm/ffmpeg-core.js';
      const localESMWASM = 'libs/ffmpeg/esm/ffmpeg-core.wasm';
      if (await headOk(localESMJS) && await headOk(localESMWASM)) {
        log('Using local ESM single-thread core.');
      } else {
        log('Using CDN ESM single-thread core.');
      }

      // Inline app (used if js/video.js is absent)
      async function runInline() {
        const ffmpeg = window.createFFmpeg({
          log: true,
          progress: ({ ratio }) => setProgress(Math.round(((ratio || 0) * 100)), 'Transcoding')
        });

        let running = false;

        async function ensureLoaded() {
          if (ffmpeg.isLoaded()) return;
          log('🔧 Loading FFmpeg core… (first run takes longer)');
          let pct = 1;
          setProgress(pct, 'Loading core');
          const tick = setInterval(() => { if (pct < 90) { pct += 2; setProgress(pct, 'Loading core'); } }, 400);
          const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('FFmpeg core load timeout (60s). Check worker/core files.')), 60000));
          try {
            await Promise.race([ffmpeg.load(), timeout]);
            clearInterval(tick);
            setProgress(95, 'Initializing');
            log('✅ FFmpeg ready');
            setProgress(100, 'Ready');
          } catch (e) {
            clearInterval(tick);
            throw e;
          }
        }

        const pickCmd = (ext, memIn, memOut) =>
          ext==='mp4' ? ['-i', memIn, '-movflags','faststart','-c','copy', memOut] :
          ext==='webm'? ['-i', memIn, '-c:v','libvpx','-b:v','1M','-c:a','libvorbis', memOut] :
          ext==='mp3' ? ['-i', memIn, '-vn', '-c:a','mp3','-q:a','2', memOut] :
                        ['-i', memIn, '-c','copy', memOut];

        async function convert() {
          const file = fileInput.files && fileInput.files[0];
          if (!file) { alert('Pick a file first.'); return; }
          btnConvert.disabled = true; btnCancel.disabled = false; dlLink.style.display = 'none'; dlLink.removeAttribute('href');
          resetProgress();
          log(`📦 Selected: ${file.name} (${(file.size/1e6).toFixed(2)} MB)`);

          try {
            running = true;
            await ensureLoaded();

            const outExt = outFormatSel.value;
            const memIn  = `in_${Date.now()}${file.name.includes('.') ? file.name.slice(file.name.lastIndexOf('.')) : '.dat'}`;
            const memOut = `out_${Date.now()}.${outExt}`;

            await ffmpeg.FS('writeFile', memIn, await window.fetchFile(file));
            log(`➡️  Loaded into memory: ${memIn}`);

            const cmd = pickCmd(outExt, memIn, memOut);
            log('▶️  ffmpeg ' + cmd.map(x => (/\s/.test(x) ? `"${x}"` : x)).join(' '));
            await ffmpeg.run(...cmd);

            const outData = await ffmpeg.FS('readFile', memOut);
            const blob = new Blob([outData], { type:
              outExt === 'mp4' ? 'video/mp4' :
              outExt === 'webm' ? 'video/webm' :
              outExt === 'mp3' ? 'audio/mpeg' : 'application/octet-stream'
            });
            const url = URL.createObjectURL(blob);
            dlLink.href = url; dlLink.download = file.name.replace(/\.[^/.]+$/,'') + '.' + outExt; dlLink.style.display = 'inline-block';
            setProgress(100, 'Done');
            log('✅ Complete.');

            try { await ffmpeg.FS('unlink', memIn); } catch(_) {}
            try { await ffmpeg.FS('unlink', memOut); } catch(_) {}
          } catch (err) {
            log('❌ Error: ' + (err && err.message ? err.message : String(err)));
            progressLabel.textContent = 'Error';
          } finally {
            running = false; btnConvert.disabled = false; btnCancel.disabled = true;
          }
        }

        function cancelRun() {
          if (running && ffmpeg.__raw?.terminate) {
            try { ffmpeg.__raw.terminate(); log('🛑 Terminated current FFmpeg run.'); } catch(_) {}
          }
          btnCancel.disabled = true; btnConvert.disabled = false;
        }

        btnConvert.addEventListener('click', convert);
        btnCancel.addEventListener('click', cancelRun);
      }

      try { await addScript('./js/video.js?v=esm1'); }
      catch { log('js/video.js not found — using inline fallback.'); await runInline(); }
      if (!btnConvert.onclick) await runInline();
    })();
  </script>
</body>
</html>
